local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local line = require "ustation/coorline"
local arc = require "ustation/coorarc"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local quat = require "ustation/quaternion"
local pipe = require "ustation/pipe"
local ust = require "ustation"
local uste = require "ustation_entries"

local dump = require "datadumper"

local ma = math

local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {ust.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local wPlatformList = {4, 5, 6, 7, 8, 10, 12, 14, 15}
local roofLengthList = {100, 95, 80, 75, 50, 25, 0}
local extWidthList = {100, 75, 50, 25, 10}
local extLengthList = {100, 90, 80, 75, 70, 65, 60, 55, 50}
local varUnaffectedList = {0, 10, 25, 50, 75, 90}
local yOffsetList = {0, 10, 20, 30, 40}

local trackLengths = {40, 60, 80, 100, 140, 160, 200, 240, 320, 400, 480, 500, 550, 850, 1050, 1750}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 20}
local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}

local fencesLengthList = {2, 2.5, 2}
local buildingList, buildingParamsList = table.unpack(require("ustation_building"))

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        {
            key = "nbTracksA",
            name = _("Number of tracks") .. "\n" .. "A",
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "nbTracksB",
            name = "B",
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "lengthA",
            name = _("Platform length") .. "(m)" .. "\n" .. "A",
            values = func.map(trackLengths, tostring),
            defaultIndex = 5
        },
        {
            key = "lengthB",
            name = "B",
            values = func.map(trackLengths, tostring),
            defaultIndex = 5
        },
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "platformLayout",
            name = _("Platform Layout"),
            values = {_("L"), _("LC"), _("LCR"), _("0"), _("C"), _("LR"), _("CR"), _("R")},
            defaultIndex = 2
        },
        {
            key = "nbTransitTracks",
            name = sp .. "\n" .. _("Transit Tracks"),
            values = func.map({0, 1, 2, 3, 4}, tostring),
            defaultIndex = 0
        },
        {
            key = "posTransitTracks",
            name = _("Position"),
            values = {_("Left"), _("Centre"), _("Sides"), _("Right")},
            defaultIndex = 1
        },
        {
            key = "convAngle",
            name = _("Convering Angle"),
            values = {"0"},
            defaultIndex = 0
        },
        {
            key = "radiusA",
            name = sp .. _("Radius") .. " A" .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "radiusB",
            name = _("Radius") .. " B" .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "curveLayout",
            name = "",
            values = {"--", "-+", "++"},
            defaultIndex = 1
        },
        {
            key = "hPlatform",
            name = sp .. "\n" .. _("Platform") .. "\n\n" .. _("Height") .. "(mm)",
            values = func.map(hPlatformList, tostring),
            defaultIndex = 3
        },
        {
            key = "wPlatform",
            name = _("Width") .. "(m)",
            values = func.map(wPlatformList, tostring),
            defaultIndex = 1
        },
        {
            key = "roofLength",
            name = _("Roof length") .. "(%)",
            values = func.map(roofLengthList, tostring),
            defaultIndex = 3
        },
        {
            key = "wExtPlatform",
            name = sp .. "\n" .. _("Platform Variation") .. "\n",
            values = func.map(extWidthList, tostring),
            defaultIndex = 0
        },
        {
            key = "varModelWidth",
            name = _("Narrowest Extremity Width") .. "(%)",
            values = {_("Uniform"), _("Linear"), _("Quadratic"), _("Quartic"), _("Gaussain"), _("Gaussain 2")},
            defaultIndex = 1
        },
        {
            key = "lExtPlatform",
            name = "",
            values = func.map(extLengthList, tostring),
            defaultIndex = 0
        },
        {
            key = "varModelLength",
            name = _("Shortest Platform") .. "(%)",
            values = {_("Uniform"), _("Linear"), _("Quadratic"), _("Quartic"), _("Gaussain"), _("Gaussain 2")},
            defaultIndex = 1
        },
        {
            key = "yOffsetPlatformSign",
            name = "",
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "yOffsetPlatform",
            name = _("Offset Platform Max.") .. "(%)",
            values = func.map(yOffsetList, tostring),
            defaultIndex = 0
        },
        {
            key = "varRefType",
            name = "",
            values = {_("Track"), _("Platform")},
            defaultIndex = 1
        },
        {
            key = "varRefPos",
            name = _("Reference"),
            values = {_("Left"), _("Center"), _("Right")},
            defaultIndex = 0
        },
        {
            key = "varNbUnaffected",
            name = "\n" .. _("Unaffected platforms") .. "(%)",
            values = func.map(varUnaffectedList, tostring),
            defaultIndex = 0
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "entrySize",
            name = sp .. "\n" .. _("Main Entry"),
            values = {"None", "S", "M", "L", "XL"},
            defaultIndex = 2
        },
        {
            key = "entryPos",
            name = _("Position"),
            values = {_("A"), _("Default"), _("B")},
            defaultIndex = 1
        },
        {
            key = "entryAType",
            name = _("Second Entry A Type"),
            values = {_("Underground"), _("Surface"), _("None")},
            defaultIndex = 1,
        },
        {
            key = "entryBType",
            name = _("Second Entry B Type"),
            values = {_("Underground"), _("Surface"), _("None")},
            defaultIndex = 1,
        },
        {
            key = "entryCType",
            name = _("Second Entry C Type"),
            values = {_("Underground"), _("Surface"), _("None")},
            defaultIndex = 1,
        },
        {
            key = "fencesPos",
            name = sp .. "\n" .. _("Fences"),
            values = {"None", "A", "B", "A+B"},
            defaultIndex = 0
        },
        {
            key = "fencesStyle",
            name = _("Fences Style"),
            values = {"A", "B", "C"},
            defaultIndex = 0
        },
        {
            key = "fencesColor",
            name = _("Fences Color"),
            values = {"White", "Green", "Yellow"},
            defaultIndex = 0
        }
    }
end

-- local arcPacker = function(length, slope)
--     return function(radiusA, oA, radiusB, oB, lengthVar, dislodgeA, dislodgeB)
--         local length = lengthVar and (length * lengthVar) or length
--         local dislodgeA = dislodgeA and (dislodgeA * length / radiusA) or 0
--         local dislodgeB = dislodgeB and (dislodgeB * length / radiusB) or 0
--         local initRadA = (radiusA > 0 and pi or 0)
--         local initRadB = (radiusB > 0 and pi or 0)
--         return function(z)
--             local z = z or 0
--             return function(lengthOverride)
--                 local l = lengthOverride and lengthOverride(length) or length
--                 return function(xDr)
--                     local dr = xDr or 0
--                     local arA = arc.byOR(oA + coor.xyz(0, 0, z), abs(radiusA - dr))
--                     local arB = arc.byOR(oB + coor.xyz(0, 0, z), abs(radiusB - dr))
--                     local radA = (radiusA > 0 and 1 or -1) * l / arA.r * 0.5
--                     local radB = (radiusB > 0 and 1 or -1) * l / arB.r * 0.5
--                     return pipe.new
--                         / arA:withLimits({
--                             sup = initRadA - radA + dislodgeA,
--                             inf = initRadA,
--                             slope = -slope
--                         })
--                         / arB:withLimits({
--                             inf = initRadB,
--                             sup = initRadB + radB + dislodgeB,
--                             slope = slope
--                         })
--                 end
--             end
--         end
--     end
-- end
local arcPacker = function(length, slope)
    return function(radiusA, oA, radiusB, oB, lengthVar, dislodgeA, dislodgeB)
        local length = lengthVar and (length * lengthVar) or length
        local dislodgeA = dislodgeA and (dislodgeA * length / radiusA) or 0
        local dislodgeB = dislodgeB and (dislodgeB * length / radiusB) or 0
        local initRad = (radiusA > 0 and pi or 0)
        return function(z)
            local z = z or 0
            return function(lengthOverride)
                local l = lengthOverride and lengthOverride(length) or length
                return function(xDr)
                    local dr = xDr or 0
                    local arA = arc.byOR(oA + coor.xyz(0, 0, z), abs(radiusA - dr))
                    local arB = arc.byOR(oB + coor.xyz(0, 0, z), abs(radiusB - dr))
                    local radA = (radiusA > 0 and 1 or -1) * l / arA.r * 0.5
                    local radB = (radiusB > 0 and 1 or -1) * l / arB.r * 0.5
                    return pipe.new
                        / arA:withLimits({
                            sup = initRad,
                            inf = initRad + radA,
                            slope = -slope
                        })
                        / arA:withLimits({
                            inf = initRad + radA,
                            sup = initRad + radA + radA,
                            slope = slope
                        })
                end
            end
        end
    end
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    param.trackType = param.trackType or 0
    param.catenary = param.catenary or 0
    
    func.forEach(
        func.filter(params({}), function(p) return p.key ~= "tramTrack" end),
        function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end


local function trackGrouping(result, ar1, ar2, ar3, ar4, ...)
    if (ar1 == nil) then dump.dump(result * pipe.map(function(x) return func.map(x, function(x) return #x end) end)) return table.unpack(result) end
    
    if (ar1 and ar2 and ar3) then
        if #ar1 == 1 and #ar2 == 2 and #ar3 == 1 then
            if (ar4 and #ar4 == 2) then
                return trackGrouping(result / {ar1, ar2} / {ar3, ar4}, ...)
            else
                return trackGrouping(result / {ar1, ar2, ar3}, ar4, ...)
            end
        end
    end
    
    if (ar1 and ar2) then
        if (#ar1 + #ar2 == 3) then
            return trackGrouping(result / {ar1, ar2}, ar3, ar4, ...)
        end
    end
    
    return trackGrouping(result / {ar1}, ar2, ar3, ar4, ...)
end

local buildStation = function(nbTracksA, nbTracksB, arcPackerA, arcPackerB, config, hasFirst, hasCentral, hasLast)
    local pW = config.wPlatform
    local tW = config.wTrack
    local bandWidth = 0.8
    local pWe = config.wExtPlatform * (pW - bandWidth * 2) + bandWidth * 2
    local fitModel = slope == 0 and ust.fitModel2D or ust.fitModel
    local generateEdges = ust.generateEdges
    local generateModels = ust.generateModels(fitModel, config)
    local generateFences = ust.generateFences(fitModel, config)
    local generateTerminals = ust.generateTerminals(config)
    local generateTerrain = ust.generateTerrain(config)
    
    local function preBuild(totalTracks, ignoreFst, ignoreLst)
        local function preBuild(nbTracks, result)
            local p = false
            local t = true
            local transitSeq = pipe.new * pipe.rep(config.nbTransitTracks)(t)
            if (nbTracks == 0) then
                local result = ignoreLst and result or (result[#result] and (result / p) or result)
                if (#transitSeq > 0) then
                    if (config.posTransitTracks == -2) then
                        result = transitSeq + result
                    elseif (config.posTransitTracks == 1) then
                        result = result + transitSeq
                    elseif (config.posTransitTracks == 0) then
                        result = pipe.new * pipe.rep(ceil(config.nbTransitTracks * 0.5))(t) + result + pipe.new * pipe.rep(floor(config.nbTransitTracks * 0.5))(t)
                    else
                        local idx = result * pipe.zip(func.seq(1, #result), {"t", "i"}) * pipe.filter(function(p) return not p.t end) * pipe.map(pipe.select("i"))
                        result = result * pipe.range(1, idx[ceil(#idx * 0.5)]) + transitSeq + result * pipe.range(idx[ceil(#idx * 0.5)] + 1, #result)
                    end
                end
                return result
            elseif (nbTracks == totalTracks and ignoreFst) then
                return preBuild(nbTracks - 1, result / t / p)
            elseif (nbTracks == totalTracks and not ignoreFst) then
                return preBuild(nbTracks - 1, result / p / t)
            elseif (nbTracks == 1 and ignoreLst) then
                return preBuild(nbTracks - 1, ((not result) or result[#result]) and (result / p / t) or (result / t))
            elseif (nbTracks == 1 and not ignoreLst) then
                return preBuild(nbTracks - 1, result / t / p)
            else
                return preBuild(nbTracks - 2, result / t / p / t)
            end
        end
        return preBuild
    end
    
    local ptListA = preBuild(nbTracksA, not hasCentral, not hasFirst)(nbTracksA, pipe.new) * pipe.rev()
    local ptListB = preBuild(nbTracksB, not hasCentral, not hasLast)(nbTracksB, pipe.new)
    
    local ptListIA = ptListA * pipe.range(1, #ptListA - (hasCentral and 1 or 0)) * pipe.zip(func.seq(1, #ptListA), {"t", "i"})
    local ptListIB = ptListB * pipe.range(hasCentral and 2 or 1, #ptListB) * pipe.zip(func.seq(#ptListA + 1, #ptListA + #ptListB + 1), {"t", "i"})
    
    local middlePos = hasCentral and #ptListA or (#ptListA + 0.5)
    local leftGroup = ptListIA * pipe.rev()
    local middleGroup = pipe.new * (hasCentral and {{i = #ptListA, t = false}} or {})
    local rightGroup = ptListIB
    dump.dump({
        l = leftGroup,
        m = middleGroup,
        r = rightGroup
    })
    
    local function platformArcGen(arcPacker)
        return function(rA, oA, rB, oB, lPct, oPct, pWe, isRight)
            local rInnerA = rA - (isRight and 1 or -1) * (0.5 * tW)
            local rOuterA = rA - (isRight and 1 or -1) * (0.5 * tW + pW)
            local rInnerB = rB - (isRight and 1 or -1) * (0.5 * tW)
            local rOuterB = rB - (isRight and 1 or -1) * (0.5 * tW + pW)
            local inner = arcPacker(rInnerA, oA, rInnerB, oB, lPct, oPct, oPct)
            local li, ls = table.unpack(inner()()())
            local ri, rs = table.unpack(arcPacker(rOuterA, oA, rOuterB, oB, lPct, oPct, oPct)()()())
            
            local param = function(la, ra, rInner)
                local mlpt = la:pt(la.inf)
                local mrpt = ra:pt(ra.inf)
                
                local mvec = (mrpt - mlpt):normalized()
                local f = mvec:dot(mlpt - la.o) > 0 and 1 or -1
                
                local elpt = la:pt(la.sup)
                local erpt = (elpt - la.o):normalized() * f * pWe + elpt
                
                local mln = line.byVecPt(mvec, mrpt)
                local pln = line.byVecPt(mvec .. coor.rotZ(pi * 0.5), erpt)
                local xpt = (mln - pln):withZ(0)
                
                local rvec = (xpt - mrpt):dot(xpt - la.o) * rInner
                
                local lenP2 = (xpt - erpt):length2()
                local lenT = (xpt - mrpt):length()
                local r = (lenP2 / lenT + lenT) * 0.5 * (rvec < 0 and 1 or -1)
                
                local o = mrpt + (xpt - mrpt):normalized() * abs(r)
                
                return r, o
            end
            
            local rA, oA = param(li, ri, rInnerA)
            local rB, oB = param(ls, rs, rInnerB)
            
            return rA + 0.5 * tW * (isRight and 1 or -1), oA, rB + 0.5 * tW * (isRight and 1 or -1), oB, {
                isRight and inner or arcPacker(rA, oA, rB, oB, lPct, oPct, oPct),
                isRight and arcPacker(rA, oA, rB, oB, lPct, oPct, oPct) or inner
            }
        end
    end
    
    local lengthFn = function(posPct) return 1 - (1 - config.lExtPlatform) * ust.varFn(config.lExtPlatform)[config.varModelLength](posPct) end
    local widthFn = function(posPct) return (1 - (1 - config.wExtPlatform) * ust.varFn(config.wExtPlatform)[config.varModelWidth](posPct)) * (pW - bandWidth * 2) + bandWidth * 2 end
    
    local function generateArcs(init, initDrA, initXA, initDrB, initXB)
        
        local function arcGen(result, rA, oA, rB, oB, isRight)
            return isRight
                and function(t, ...)
                    if t == nil then
                        return result * pipe.sort(function(l, r) return l.i < r.i end) * pipe.map(pipe.select("a"))
                    else
                        local posPct = abs(t.i - middlePos) / (#rightGroup)
                        local isVar = posPct >= config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and -posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPackerB(rA - tW, oA, rB - tW, oB, isVar and lengthPct or 1, offsetPct, offsetPct)}},
                                rA - tW, oA, rB - tW, oB, true)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(result / {
                                    i = t.i,
                                    a = {
                                        arcPackerB(rA - (0.5 * tW), oA, rB - (0.5 * tW), oB, lengthPct, offsetPct, offsetPct),
                                        arcPackerB(rA - (0.5 * tW + pW), oA, rB - (0.5 * tW + pW), oB, lengthPct, offsetPct, offsetPct)
                                    }},
                                rA - pW, oA, rB - pW, oB, true)(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local rA, oA, rB, oB, a = platformArcGen(arcPackerB)(rA, oA, rB, oB, lengthPct, offsetPct, pWe, true)
                                return arcGen(result / {i = t.i, a = a},
                                    rA, oA, rB, oB, true)(...)
                            end
                        end
                    end
                end
                or function(t, ...)
                    if t == nil then
                        return arcGen(result, initDrA[#initDrA], initXA[#initXA], initDrB[#initDrB], initXB[#initXB], true)(table.unpack(rightGroup))
                    else
                        local posPct = abs(t.i - middlePos) / (#leftGroup)
                        local isVar = posPct >= config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPackerA(rA + tW, oA, rB + tW, oB, lengthPct, offsetPct, offsetPct)}},
                                rA + tW, oA, rB + tW, oB)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(result / {
                                    i = t.i,
                                    a = {
                                        arcPackerA(rA + (0.5 * tW + pW), oA, rB + (0.5 * tW + pW), oB, lengthPct, offsetPct, offsetPct),
                                        arcPackerA(rA + (0.5 * tW), oA, rB + (0.5 * tW), oB, lengthPct, offsetPct, offsetPct)
                                    }},
                                rA + pW, oA, rB + pW, oB)(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local rA, oA, rB, oB, a = platformArcGen(arcPackerA)(rA, oA, rB, oB, lengthPct, offsetPct, pWe, false)
                                return arcGen(result / {i = t.i, a = a},
                                    rA, oA, rB, oB)(...)
                            end
                        end
                    end
                end
        end
        local rs = arcGen(init, initDrA[1], initXA[1], initDrB[1], initXB[1])(table.unpack(leftGroup))
        return rs
    end
    
    local allArcs = pipe.exec * function()
        local oA = coor.xyz(config.rA, 0, 0)
        local oB = coor.xyz(config.rB, 0, 0)
        
        if (hasCentral) then
            local isVar = config.varNbUnaffected == 0
            -- if (not isVar) then
            return generateArcs(
                pipe.new / {
                    i = middlePos,
                    a = {
                        arcPackerA(config.rA + 0.5 * pW, oA, config.rA + 0.5 * pW, oA),
                        arcPackerB(config.rB - 0.5 * pW, oB, config.rB - 0.5 * pW, oB)
                    }
                },
                {
                    config.rA - (-0.5 * pW + 0.5 * tW),
                    config.rB - (0.5 * pW - 0.5 * tW)
                }, {oA, oB},
                {
                    config.rA - (-0.5 * pW + 0.5 * tW),
                    config.rB - (0.5 * pW - 0.5 * tW)
                }, {oA, oB}
        )
        -- else
        --     local rAR, oAR, rBR, oBR, a = platformArcGen(config.rA + 0.5 * pW, oA, config.rA + 0.5 * pW, oA, 1, 0, widthFn(0), true)
        --     return generateArcs(
        --         {
        --             i = middlePos,
        --             a = a
        --         },
        --         {
        --             config.rA - (-0.5 * pW + 0.5 * tW),
        --             rAR
        --         }, {oA, oAR},
        --         {
        --             config.rA - (-0.5 * pW + 0.5 * tW),
        --             rAR
        --         }, {oA, oAR}
        -- )
        -- end
        else
            return generateArcs(
                pipe.new * {},
                {
                    config.rA - (0.5 * tW),
                    config.rB - (- 0.5 * tW)
                }, {oA, oB},
                {
                    config.rA - (0.5 * tW),
                    config.rB - ( - 0.5 * tW)
                }, {oA, oB}
        )
        end
    end
    
    local isLeftTrack = #allArcs[1] == 1
    local isRightTrack = #allArcs[#allArcs] == 1
    
    allArcs = pipe.exec * function()
        local refZ = config.hPlatform + 0.53
        return allArcs
            * pipe.map(function(p)
                if (#p == 2) then
                    local arcL, arcR = table.unpack(p)
                    
                    local lane = {
                        l = arcL(refZ)(function(l) return l - 3 end),
                        r = arcR(refZ)(function(l) return l - 3 end)
                    }
                    local general = {
                        l = arcL(refZ)(),
                        r = arcR(refZ)()
                    }
                    local roof = {
                        l = arcL(refZ)(function(l) return l * config.roofLength end),
                        r = arcR(refZ)(function(l) return l * config.roofLength end)
                    }
                    local terrain = {
                        l = arcL()(function(l) return l + 5 end),
                        r = arcR()(function(l) return l + 5 end)
                    }
                    
                    local arcGen = function(p, o) return {
                        l = p.l(o),
                        r = p.r(-o)
                    } end
                    
                    local arcs = {
                        lane = arcGen(lane, 1),
                        edge = arcGen(general, -0.5),
                        surface = arcGen(general, 0.3),
                        access = arcGen(general, -4.25),
                        roof = {
                            edge = arcGen(roof, -0.5),
                            surface = arcGen(roof, 0.5)
                        },
                        terrain = arcGen(terrain, -0.5)
                    }
                    
                    local lc, rc, c = ust.bitLatCoords(5)(arcs.lane.l, arcs.lane.r)
                    local lsc, rsc, lac, rac, lsuc, rsuc, sc = ust.bitLatCoords(5)(arcs.edge.l, arcs.edge.r, arcs.access.l, arcs.access.r, arcs.surface.l, arcs.surface.r)
                    local lcc, rcc, cc = ust.bitLatCoords(10)(arcs.edge.l, arcs.edge.r)
                    local lpc, rpc, lpic, rpic, pc = ust.bitLatCoords(5)(arcs.roof.edge.l, arcs.roof.edge.r, arcs.roof.surface.l, arcs.roof.surface.r)
                    local lppc, rppc, ppc = ust.bitLatCoords(10)(arcs.roof.edge.l, arcs.roof.edge.r)
                    local ltc, rtc, tc = ust.bitLatCoords(5)(arcs.terrain.l, arcs.terrain.r)
                    return {
                        [1] = arcL,
                        [2] = arcR,
                        lane = func.with(arcs.lane, {lc = lc, rc = rc, c = c}),
                        platform = func.with(arcs.edge, {lc = lsc, rc = rsc, c = sc}),
                        access = func.with(arcs.access, {lc = lac, rc = rac, c = sc}),
                        surface = func.with(arcs.surface, {lc = lsuc, rc = rsuc, c = sc}),
                        chair = func.with(arcs.edge, {lc = lcc, rc = rcc, c = cc}),
                        roof = {
                            edge = func.with(arcs.roof.edge, {lc = lpc, rc = rpc, c = pc}),
                            surface = func.with(arcs.roof.surface, {lc = lpic, rc = rpic, c = pc}),
                            pole = func.with(arcs.roof.edge, {lc = lppc, rc = rppc, c = ppc})
                        },
                        terrain = func.with(arcs.terrain, {lc = ltc, rc = rtc, c = tc}),
                        hasLower = (sc - 5 - floor(sc * 0.5) > 0) and (c - 5 - floor(c * 0.5) > 0),
                        hasUpper = (sc + 5 + floor(sc * 0.5) <= #lsc) and (c + 5 + floor(c * 0.5) <= #lc)
                    }
                else
                    return p
                end
            end)
    end
    
    local entryConfig = {
        main = isLeftTrack and {pos = false, model = false} or config.entries.main,
        street = {
            func.mapi(config.entries.street[1], function(t, i) return t and not (config.entries.main.model and config.entries.main.pos + 2 == i) and not isLeftTrack end),
            func.mapi(config.entries.street[2], function(t, i) return t and not isRightTrack end),
        },
        underground = {
            func.mapi(config.entries.underground[1], function(t, i) return
                (t or (isLeftTrack and config.entries.street[1][i]))
                    and not (config.entries.main.model and config.entries.main.pos + 2 == i) end),
            func.mapi(config.entries.underground[2], function(t, i) return t or (isRightTrack and config.entries.street[2][i]) end),
        },
        allArcs = allArcs,
        arcCoords = allArcs * pipe.filter(function(a) return #a > 1 end)
    }
    local entries = pipe.new
        / uste.buildEntry(config, entryConfig)
        / uste.buildUndergroundEntry(config, entryConfig)
        / uste.buildSecondEntrySlope(config, entryConfig)
    
    local function build(edges, terminals, terminalsGroup, models, terrain, gr, ...)
        local isLeftmost = #models == 0
        local isRightmost = #{...} == 0
        if (gr == nil) then
            local buildEntryPath = entries * pipe.map(pipe.select("access")) * pipe.flatten()
            local buildFace = entries * pipe.map(pipe.select("terrain")) * pipe.flatten()
            local buildAccessRoad = entries * pipe.map(pipe.select("street")) * pipe.flatten()
            local buildLanes = entries * pipe.map(pipe.select("lane")) * pipe.flatten()
            return edges, buildAccessRoad, terminals, terminalsGroup,
                models + buildEntryPath + buildLanes,
                terrain + buildFace
        elseif (#gr == 3) then
            edges = generateEdges(edges, true, gr[1][1])
            edges = generateEdges(edges, false, gr[3][1])
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, gr[2], {true, true})
            return build(
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(gr[2])
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], true, true) or {})
                + (config.rightFences and isRightmost and generateFences(gr[3][1], false, true) or {}),
                terrain + generateTerrain(gr[2]),
                ...)
        elseif (#gr == 2 and #gr[1] == 1 and #gr[2] > 1) then
            edges = generateEdges(edges, true, gr[1][1])
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, gr[2], {true, false})
            return build(
                edges,
                terminals,
                terminalsGroup,
                models
                + generateModels(gr[2], entries[3].edgeBuilder(isLeftmost, isRightmost))
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], true, true, entries[3].fenceFilter) or {})
                + (config.rightFences and isRightmost and generateFences(gr[2][2], false, false, entries[3].fenceFilter) or {}),
                terrain + generateTerrain(gr[2]),
                ...)
        elseif (#gr == 2 and #gr[1] > 1 and #gr[2] == 1) then
            edges = generateEdges(edges, false, gr[2][1])
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, gr[1], {false, true})
            return build(edges,
                terminals,
                terminalsGroup,
                models
                + generateModels(gr[1], entries[3].edgeBuilder(isLeftmost, isRightmost))
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], true, false, entries[3].fenceFilter) or {})
                + (config.rightFences and isRightmost and generateFences(gr[2][1], false, true, entries[3].fenceFilter) or {}),
                terrain + generateTerrain(gr[1]),
                ...)
        elseif (#gr == 1 and #gr[1] > 1) then
            return build(edges,
                terminals,
                terminalsGroup,
                models
                + generateModels(gr[1], entries[3].edgeBuilder(isLeftmost, isRightmost))
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], true, false, entries[3].fenceFilter) or {})
                + (config.rightFences and isRightmost and generateFences(gr[1][1], false, false, entries[3].fenceFilter) or {}),
                terrain + generateTerrain(gr[1]),
                ...)
        else
            edges = generateEdges(edges, false, gr[1][1])
            return build(edges,
                terminals,
                terminalsGroup,
                models,
                terrain,
                ...)
        end
    end
    
    return build(pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, trackGrouping(pipe.new, table.unpack(allArcs)))
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = wPlatformList[params.wPlatform + 1]
        local roofLength = roofLengthList[params.roofLength + 1] * 0.01
        local mainBuilding = params.entrySize > 0 and buildingList[params.entrySize]
        local fencesLength = fencesLengthList[params.fencesStyle + 1]
        local fencesModel = {
            "fences/" .. tostring(params.fencesColor + 1) .. "/platform_fences_" .. tostring(params.fencesStyle + 1) .. ".mdl",
            "fences/" .. tostring(params.fencesColor + 1) .. "/platform_fences_pole_" .. tostring(params.fencesStyle + 1) .. ".mdl",
        }
        
        
        local nbTracksA = trackNumberList[params.nbTracksA + 1]
        local nbTracksB = trackNumberList[params.nbTracksB + 1]
        local radiusA = (rList[params.radiusA + 1] * 1000) * (params.curveLayout == 2 and 1 or -1)
        local radiusB = (rList[params.radiusB + 1] * 1000) * (params.curveLayout == 0 and -1 or 1)
        
        if (params.curveLayout == 0 and radiusA > radiusB) or (params.curveLayout == 2 and radiusA < radiusB) then
            radiusA, radiusB = radiusB, radiusA
        end
        
        local slope = slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local lengthA = min(trackLengths[params.lengthA + 1], abs(radiusA * pi * 1.75))
        local lengthB = min(trackLengths[params.lengthB + 1], abs(radiusB * pi * 1.75))
        
        local entryConfig = {
            main = {
                pos = mainBuilding and (params.entryPos - 1),
                model = mainBuilding,
            },
            street = {
                {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1},
                {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1}
            },
            underground = {
                {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0},
                {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0}
            }
        }
        
        local edge, streetEdge, terminals, terminalsGroup, models, terrain =
            buildStation(nbTracksA, nbTracksB,
                arcPacker(lengthA, slope),
                arcPacker(lengthB, slope),
                {
                    nbTransitTracks = params.nbTransitTracks,
                    posTransitTracks = params.posTransitTracks - 2,
                    rA = radiusA,
                    rB = radiusB,
                    hPlatform = hPlatform,
                    wPlatform = wPlatform,
                    wExtPlatform = extWidthList[params.wExtPlatform + 1] * 0.01,
                    lExtPlatform = extLengthList[params.lExtPlatform + 1] * 0.01,
                    yOffsetPlatform = yOffsetList[params.yOffsetPlatform + 1] * (params.yOffsetPlatformSign == 0 and 0.01 or -0.01),
                    varRefPos = params.varRefPos - 1,
                    varRefIsTrack = params.varRefType == 0,
                    varNbUnaffected = varUnaffectedList[params.varNbUnaffected + 1] * 0.01,
                    varModelLength = params.varModelLength + 1,
                    varModelWidth = params.varModelWidth + 1,
                    wTrack = 5,
                    roofLength = roofLength,
                    buildingParams = buildingParamsList[params.entrySize],
                    slope = slope,
                    fencesModel = fencesModel,
                    fencesLength = fencesLength,
                    leftFences = params.fencesPos == 1 or params.fencesPos == 3,
                    rightFences = params.fencesPos == 2 or params.fencesPos == 3,
                    entries = entryConfig
                },
                ({true, true, true, false, false, true, false, false})[params.platformLayout + 1],
                ({false, true, true, false, true, false, true, false})[params.platformLayout + 1],
                ({false, false, true, false, false, true, true, true})[params.platformLayout + 1]
        )
        return
            pipe.new
            * {
                edgeLists = pipe.new
                / (pipe.new * {edge * station.mergeEdges} * station.prepareEdges * trackBuilder.normal())
                -- + streetEdge
                ,
                models = terminals + models,
                terminalGroups = {}, -- terminalsGroup,
                terrainAlignmentLists = station.mergePoly(table.unpack(terrain))()
            -- groundFaces = terrain
            -- * pipe.map(pipe.select("equal"))
            -- * pipe.filter(pipe.noop())
            -- * pipe.flatten()
            -- * pipe.map(function(f) return {
            --     {face = f, modes = {{type = "FILL", key = "industry_gravel_small_01"}}},
            --     {face = f, modes = {{type = "STROKE_OUTER", key = "building_paving"}}}
            -- } end)
            -- * pipe.flatten()
            }
    end
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station T"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 27218,
        params = params(),
        updateFn = updateFn()
    }
end
