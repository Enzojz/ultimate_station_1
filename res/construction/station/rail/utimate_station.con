local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local line = require "ustation/coorline"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local quat = require "ustation/quaternion"
local pipe = require "ustation/pipe"
local ust = require "ustation"

local du = require "datadumper"

local ma = math

local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {ust.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local wPlatformList = {4, 5, 6, 7, 8}
local roofLengthList = {100, 95, 80, 75, 50, 25, 0}
local extWidthList = {100, 75, 50, 25, 10}
local extLengthList = {100, 90, 80, 75, 70, 65, 60, 55, 50, 40}
local varUnaffectedList = {0, 10, 25, 50, 75, 90}
local yOffsetList = {0, 10, 20, 30, 40, 50, 60}

local trackLengths = {40, 60, 80, 100, 140, 160, 200, 240, 320, 400, 480, 500, 550, 850, 1050, 1750}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 20}
local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}

local buildingList = {
    "main_building_size1.mdl",
    "main_building_size2.mdl",
    "main_building_size4.mdl",
    "main_building_size5.mdl",
}

local fencesLengthList = {
    2, 2.5, 2
}

local bZ = 0.8
local buildingParamsList = {
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.5, 0),
            coor.xyz(5, -1.5, 0)
        },
        pass = {
            coor.xyz(1, 0, -bZ)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 9,
        xOffset = 5.3
    },
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.5, 0),
            coor.xyz(5, -1.5, 0)
        },
        pass = {
            coor.xyz(0, 0, 0)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 15.5,
        xOffset = 5.3
    },
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.8, 0),
            coor.xyz(5, -1.8, 0)
        },
        pass = {
            coor.xyz(0, 0, 0)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 22.5,
        xOffset = 5.3
    },
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.8, 0),
            coor.xyz(5, -1.8, 0)
        },
        pass = {
            coor.xyz(0, 0, 0)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 30,
        xOffset = 5.3
    }
}

local il = pipe.interlace({"s", "i"})

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "length",
            name = _("Platform length") .. "(m)",
            values = func.map(trackLengths, tostring),
            defaultIndex = 5
        },
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "trackLayout",
            name = _("Track Layout"),
            values = func.map({1, 2, 3, 4}, tostring),
            defaultIndex = 1
        },
        {
            key = "nbTransitTracks",
            name = sp .. "\n" .. _("Transit Tracks"),
            values = func.map({0, 1, 2, 3, 4}, tostring),
            defaultIndex = 0
        },
        {
            key = "posTransitTracks",
            name = _("Position"),
            values = {_("Left"), _("Centre"), _("Sides"), _("Right")},
            defaultIndex = 1
        },
        {
            key = "sign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "hPlatform",
            name = sp .. "\n" .. _("Platform") .. "\n\n" .. _("Height") .. "(mm)",
            values = func.map(hPlatformList, tostring),
            defaultIndex = 3
        },
        {
            key = "wPlatform",
            name = _("Width") .. "(m)",
            values = func.map(wPlatformList, tostring),
            defaultIndex = 1
        },
        {
            key = "roofLength",
            name = _("Roof length") .. "(%)",
            values = func.map(roofLengthList, tostring),
            defaultIndex = 3
        },
        {
            key = "wExtPlatform",
            name = sp .. "\n" .. _("Platform Variation") .. "\n",
            values = func.map(extWidthList, tostring),
            defaultIndex = 0
        },
        {
            key = "varModelWidth",
            name = _("Narrowest Extremity Width") .. "(%)",
            values = {_("Uniform"), _("Linear"), _("Quadratic"), _("Quartic"), _("Gaussain"), _("Gaussain 2")},
            defaultIndex = 1
        },
        {
            key = "lExtPlatform",
            name = "\n",
            values = func.map(extLengthList, tostring),
            defaultIndex = 0
        },
        {
            key = "varModelLength",
            name = _("Shortest Platform") .. "(%)",
            values = {_("Uniform"), _("Linear"), _("Quadratic"), _("Quartic"), _("Gaussain"), _("Gaussain 2")},
            defaultIndex = 1
        },
        {
            key = "yOffsetPlatformSign",
            name = "\n",
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "yOffsetPlatform",
            name = _("Offset Platform Max.") .. "(%)",
            values = func.map(yOffsetList, tostring),
            defaultIndex = 0
        },
        {
            key = "varRefType",
            name = "\n",
            values = {_("Track"), _("Platform")},
            defaultIndex = 1
        },
        {
            key = "varRefPos",
            name = _("Reference"),
            values = {_("Left"), _("Center"), _("Right")},
            defaultIndex = 0
        },
        {
            key = "varNbUnaffected",
            name = "\n" .. _("Unaffected platforms") .. "(%)",
            values = func.map(varUnaffectedList, tostring),
            defaultIndex = 0
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "entrySize",
            name = sp .. "\n" .. _("Entry"),
            values = {"None", "S", "M", "L", "XL"},
            defaultIndex = 2
        },
        {
            key = "entryPos",
            name = _("Position"),
            values = {_("A"), _("Default"), _("B")},
            defaultIndex = 1
        },
        {
            key = "entryAType",
            name = _("Second Entry A Type"),
            values = {_("Underground"), _("Surface"), _("None")},
            defaultIndex = 1,
        },
        {
            key = "entryBType",
            name = _("Second Entry B Type"),
            values = {_("Underground"), _("Surface"), _("None")},
            defaultIndex = 1,
        },
        {
            key = "entryCType",
            name = _("Second Entry C Type"),
            values = {_("Underground"), _("Surface"), _("None")},
            defaultIndex = 1,
        },
        {
            key = "fencesPos",
            name = sp .. "\n" .. _("Fences"),
            values = {"None", "A", "B", "A+B"},
            defaultIndex = 0
        },
        {
            key = "fencesStyle",
            name = _("Fences Style"),
            values = {"A", "B", "C"},
            defaultIndex = 0
        },
        {
            key = "fencesColor",
            name = _("Fences Color"),
            values = {"White", "Green", "Yellow"},
            defaultIndex = 0
        }
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    param.trackType = param.trackType or 0
    param.catenary = param.catenary or 0
    
    func.forEach(
        func.filter(params({}), function(p) return p.key ~= "tramTrack" end),
        function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)
end


local function trackGrouping(result, ar1, ar2, ar3, ...)
    if (ar1 == nil) then return table.unpack(result) end
    
    if (ar1 and ar2 and ar3) then
        if #ar1 == 1 and #ar2 == 2 and #ar3 == 1 then
            return trackGrouping(result / {ar1, ar2, ar3}, ...)
        end
    end
    
    if (ar1 and ar2) then
        if (#ar1 + #ar2 == 3) then
            return trackGrouping(result / {ar1, ar2}, ar3, ...)
        end
    end
    
    return trackGrouping(result / {ar1}, ar2, ar3, ...)
end

local buildUndergroundEntry = function(config, entryConfig)
    local allArcs = entryConfig.allArcs
    local arcCoords = entryConfig.arcCoords
    local transZ = coor.transZ(-config.hPlatform - 0.53 - 7.5)
    
    local edgeBuilder = function(isLeftmost, isRightmost, c)
        local platformEdgeO = pipe.new * pipe.rep(c - 2)("platform_edge") / "platform_corner"
        return platformEdgeO, platformEdgeO
    end
    
    local accessBuilder = function()
        local transZ = coor.transZ(-config.hPlatform - 0.53)
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local enabler = i == 1 and entryConfig.underground.left or entryConfig.underground.right
                local pl = p.platform
                local lpt = pipe.new
                / (p.hasLower and pl.lc[pl.c - 2 - floor(pl.c * 0.5)])
                / pl.lc[pl.c]
                / (p.hasUpper and pl.lc[pl.c + 2 + floor(pl.c * 0.5)])
                
                local rpt = pipe.new
                / (p.hasLower and pl.rc[pl.c - 2 - floor(pl.c * 0.5)])
                / pl.rc[pl.c]
                / (p.hasUpper and pl.rc[pl.c + 2 + floor(pl.c * 0.5)])
                
                return pipe.mapn(lpt, rpt, {1, 2, 3})(function(l, r, i)
                    return (l and r) and enabler[i] and {pt = (i == 1 and l or r) .. transZ, vec = (i == 1 and (l - r) or (r - l)):withZ(0):normalized()}
                end)
            end)
            * function(ls) return func.map({1, 2, 3}, function(i) return ls * pipe.map(pipe.select(i)) end) end
            * pipe.mapi(function(ls, i)
                local idxPt = allArcs
                    * pipe.zip(func.seq(1, #allArcs), {"p", "i"})
                    * pipe.filter(function(a) return #(a.p) == 2 end)
                    * pipe.map(pipe.select("i"))
                
                local fst = func.min(idxPt, function(l, r) return l < r end)
                local lst = func.max(idxPt, function(l, r) return l < r end)
                
                return pipe.new
                    / (ls[2] and station.newModel("underground_entry.mdl",
                        coor.rotZ(-0.5 * pi),
                        coor.transX(#allArcs == lst and -0.5 or -0.5 + (#allArcs - lst) * config.wTrack),
                        ust.mRot(ls[2].vec),
                        coor.trans(ls[2].pt)
                    ))
                    / (
                    ls[1] and
                    station.newModel("underground_entry.mdl",
                        coor.rotZ(-0.5 * pi),
                        coor.transX(fst == 1 and -0.5 or (fst - 1) * config.wTrack),
                        ust.mRot(ls[1].vec),
                        coor.trans(ls[1].pt)
                    ))
                    * pipe.filter(pipe.noop())
            end)
            * pipe.flatten()
            * pipe.filter(pipe.noop())
    end
    
    local terrainBuilder = function()
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local enabler = i == 1 and entryConfig.underground.left or entryConfig.underground.right
                local pl = p.platform
                local lpt = pipe.new
                / (p.hasLower and pl.lc[pl.c - 2 - floor(pl.c * 0.5)])
                / pl.lc[pl.c]
                / (p.hasUpper and pl.lc[pl.c + 2 + floor(pl.c * 0.5)])
                
                local rpt = pipe.new
                / (p.hasLower and pl.rc[pl.c - 2 - floor(pl.c * 0.5)])
                / pl.rc[pl.c]
                / (p.hasUpper and pl.rc[pl.c + 2 + floor(pl.c * 0.5)])
                
                return pipe.mapn(lpt, rpt, {1, 2, 3})(function(l, r)
                    return (l and r) and enabler[i] and {pt = (i == 1 and l or r) .. transZ, vec = (i == 1 and (l - r) or (r - l)):withZ(0):normalized()}
                end)
            end)
            * function(ls) return func.map({1, 2, 3}, function(i) return ls * pipe.map(pipe.select(i)) end) end
            * pipe.mapi(function(ls, i)
                local idxPt = allArcs
                    * pipe.zip(func.seq(1, #allArcs), {"p", "i"})
                    * pipe.filter(function(a) return #(a.p) == 2 end)
                    * pipe.map(pipe.select("i"))
                
                local fst = func.min(idxPt, function(l, r) return l < r end)
                local lst = func.max(idxPt, function(l, r) return l < r end)
                
                local vec1 = ls[1] and (ls[1].vec .. coor.rotZ(0.5 * pi)) * 4
                local vec2 = ls[2] and (ls[2].vec .. coor.rotZ(0.5 * pi)) * 4
                
                return pipe.new
                    / (ls[2] and {
                        ls[2].pt + vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack - 2),
                        ls[2].pt - vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack - 2),
                        ls[2].pt - vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack + 15),
                        ls[2].pt + vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack + 15)
                    })
                    / (
                    ls[1] and
                    {
                        ls[1].pt + vec1 + ls[1].vec * ((fst - 1) * config.wTrack - 2),
                        ls[1].pt - vec1 + ls[1].vec * ((fst - 1) * config.wTrack - 2),
                        ls[1].pt - vec1 + ls[1].vec * ((fst - 1) * config.wTrack + 15),
                        ls[1].pt + vec1 + ls[1].vec * ((fst - 1) * config.wTrack + 15)
                    })
                    * pipe.filter(pipe.noop())
            end)
            * pipe.flatten()
            * function(f)
                return pipe.new /
                    {
                        less = f * pipe.map(pipe.map(function(c) return c .. coor.transZ(0.53 + 7.5) end)) * pipe.map(station.finalizePoly),
                        slot = f * pipe.map(station.finalizePoly)
                    }
            end
    end
    
    local streetBuilder = function()
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local enabler = i == 1 and entryConfig.underground.left or entryConfig.underground.right
                local pl = p.platform
                local lpt = pipe.new
                / (p.hasLower and pl.lc[pl.c - 2 - floor(pl.c * 0.5)])
                / pl.lc[pl.c]
                / (p.hasUpper and pl.lc[pl.c + 2 + floor(pl.c * 0.5)])
                
                local rpt = pipe.new
                / (p.hasLower and pl.rc[pl.c - 2 - floor(pl.c * 0.5)])
                / pl.rc[pl.c]
                / (p.hasUpper and pl.rc[pl.c + 2 + floor(pl.c * 0.5)])
                
                return pipe.mapn(lpt, rpt, {1, 2, 3})(function(l, r, i)
                    return (l and r) and enabler[i] and {pt = l:avg(r) .. transZ, vec = (i == 1 and (l - r) or (r - l)):withZ(0) * 0.5}
                end)
            end)
            * function(ls) return func.map({1, 2, 3}, function(i) return ls * pipe.map(pipe.select(i)) end) end
            -- * pipe.filter(function(ls) return #ls == 2 end)
            * pipe.mapi(function(ls, i)
                local idxPt = allArcs
                    * pipe.zip(func.seq(1, #allArcs), {"p", "i"})
                    * pipe.filter(function(a) return #(a.p) == 2 end)
                    * pipe.map(pipe.select("i"))
                
                local fst = func.min(idxPt, function(l, r) return l < r end)
                local lst = func.max(idxPt, function(l, r) return l < r end)
                
                local underground = pipe.new
                    / (ls[1] and {
                        ls[1].pt,
                        ls[1].pt + (fst == 1
                        and ls[1].vec + ls[1].vec:normalized() * (-0.5)
                        or ls[1].vec + ls[1].vec:normalized() * (-0.5 + (fst - 1) * config.wTrack)),
                        ls[1].vec,
                        ls[1].vec,
                    })
                    / (ls[2] and {
                        ls[2].pt,
                        ls[2].pt + (#allArcs == lst
                        and ls[2].vec + ls[2].vec:normalized() * (-0.5)
                        or ls[2].vec + ls[2].vec:normalized() * (-0.5 + (#allArcs - lst) * config.wTrack)),
                        ls[2].vec,
                        ls[2].vec,
                    })
                    / (ls[1] and ls[2] and
                    {
                        ls[1].pt,
                        ls[2].pt,
                        -ls[1].vec,
                        ls[2].vec,
                    }
                    )
                    * pipe.filter(pipe.noop())
                
                local surface = underground * pipe.range(1, 2) * pipe.map(function(e) return {e[2], e[2] + e[3]:normalized() * 8, e[3], e[3]} end)
                    * pipe.range(i == 1 and 2 or 1, 2)
                
                return {
                    underground = underground,
                    surface = surface,
                    surface2 = surface * pipe.map(function(e) return {e[2], e[2] + e[3]:normalized() * 10, e[3], e[3]} end)
                }
            end)
            * function(ls)
                local ug = ls * pipe.map(function(ls) return {
                    edge = ls.underground,
                    snap = pipe.new * pipe.rep(#ls.underground)({false, false})
                } end)
                local su = ls * pipe.map(function(ls) return {
                    edge = ls.surface,
                    snap = pipe.new * pipe.rep(#ls.surface)({false, false})
                } end)
                
                local su2 = ls * pipe.map(function(ls) return {
                    edge = ls.surface2,
                    snap = pipe.new * pipe.rep(#ls.surface2)({false, true})
                } end)
                
                return
                    {
                        pipe.new * {ug * station.mergeEdges} * station.prepareEdges * pipe.with(
                            {
                                type = "STREET",
                                edgeType = "TUNNEL",
                                edgeTypeName = "ust_void.lua",
                                params =
                                {
                                    type = "station_pass.lua",
                                    tramTrackType = "NO"
                                }
                            }
                        ),
                        pipe.new * {su * station.mergeEdges} * station.prepareEdges * pipe.with(
                            {
                                type = "STREET",
                                alignTerrain = false,
                                params =
                                {
                                    type = "station_pass.lua",
                                    tramTrackType = "NO"
                                }
                            }
                        ),
                        pipe.new * {su2 * station.mergeEdges} * station.prepareEdges * pipe.with(
                            {
                                type = "STREET",
                                alignTerrain = false,
                                params =
                                {
                                    type = "station_pass_2.lua",
                                    tramTrackType = "NO"
                                }
                            }
                    )
                    }
            end
    end
    
    local laneBuilder = function()
        local function strCoor(l, r, b)
            local vec = (r - l):withZ(0):normalized() * 1.5 .. coor.rotZ(0.5 * pi)
            local ref = l:avg(r) .. transZ
            return
                {
                    ust.unitLane(ref - vec, b),
                    ust.unitLane(ref + vec, ref - vec),
                }
        end
        
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.map(function(p)
                local pl, la = p.platform, p.lane
                local fplc = floor(pl.c * 0.5)
                return pipe.new
                    + (p.hasUpper and strCoor(
                        pl.lc[pl.c + 2 + fplc],
                        pl.rc[pl.c + 2 + fplc],
                        pl.lc[pl.c + 3 + fplc]:avg(pl.rc[pl.c + 3 + fplc]) - coor.xyz(0, 0, 3.5)
                    ) or {})
                    + (p.hasLower and strCoor(
                        pl.rc[pl.c - 2 - fplc],
                        pl.lc[pl.c - 2 - fplc],
                        pl.lc[pl.c - 3 - fplc]:avg(pl.rc[pl.c - 3 - fplc]) - coor.xyz(0, 0, 3.5)
                    ) or {})
                    + strCoor(
                        pl.lc[pl.c],
                        pl.rc[pl.c],
                        pl.lc[pl.c + 2]:avg(pl.rc[pl.c + 2]) - coor.xyz(0, 0, 3.5)
                    )
                    + strCoor(
                        pl.rc[pl.c],
                        pl.lc[pl.c],
                        pl.lc[pl.c - 2]:avg(pl.rc[pl.c - 2]) - coor.xyz(0, 0, 3.5)
            )
            end)
            * pipe.flatten()
    end
    
    return {
        access = accessBuilder(),
        lane = laneBuilder(),
        terrain = terrainBuilder(),
        street =  streetBuilder()
    }
end

local buildSecondEntrySlope = function(config, entryConfig)
    local allArcs = entryConfig.allArcs
    local arcCoords = entryConfig.arcCoords
    
    local edgeBuilder = function()
        return function(isLeftmost, isRightmost, c, q)
            local fc = floor(c * 0.5)
            local platformEdgeO = pipe.new
                * pipe.rep(c - 2)("platform_edge")
                * pipe.mapi(function(p, i) return (i == fc + 4 or (i == 1 and q == 2)) and "platform_edge_open" or "platform_edge" end)
                / "platform_corner"
            
            local platformEdgeL = isLeftmost and platformEdgeO or pipe.new * pipe.rep(c - 2)("platform_edge") / "platform_corner"
            local platformEdgeR = isRightmost and platformEdgeO or pipe.new * pipe.rep(c - 2)("platform_edge") / "platform_corner"
            return platformEdgeL, platformEdgeR
        end
    end
    
    local sizeBuilder = function(p, i)
        local pl = p.platform
        local ac = p.access
        local l, r = i == 1 and pl.lc or pl.rc, i == 1 and ac.lc or ac.rc
        local fplc, facc = floor(pl.c * 0.5), floor(ac.c * 0.5)
        
        return pipe.new
            / (i > 1 and {
                ust.assembleSize(
                    {i = l[pl.c + 1], s = l[pl.c]},
                    {i = r[ac.c + 1], s = r[ac.c]}
                ),
                ust.assembleSize(
                    {i = l[pl.c + 2], s = l[pl.c + 1]},
                    {i = r[ac.c + 2], s = r[ac.c + 1]}
            ),
            })
            / (p.hasUpper and
            {
                ust.assembleSize(
                    {i = l[pl.c + 4 + fplc], s = l[pl.c + 3 + fplc]},
                    {i = r[ac.c + 4 + facc], s = r[ac.c + 3 + facc]}
                ),
                ust.assembleSize(
                    {i = l[pl.c + 5 + fplc], s = l[pl.c + 4 + fplc]},
                    {i = r[ac.c + 5 + facc], s = r[ac.c + 4 + facc]}
            )
            })
            / (p.hasLower and
            {
                ust.assembleSize(
                    {i = l[pl.c - 4 - fplc], s = l[pl.c - 3 - fplc]},
                    {i = r[ac.c - 4 - facc], s = r[ac.c - 3 - facc]}
                ),
                ust.assembleSize(
                    {i = l[pl.c - 5 - fplc], s = l[pl.c - 4 - fplc]},
                    {i = r[ac.c - 5 - facc], s = r[ac.c - 4 - facc]}
            )
            })
    end
    
    local accessBuilder = function()
        local platformZ = config.hPlatform + 0.53
        local tZ = coor.transZ(config.hPlatform - 1.4)
        local fitModel = config.slope == 0 and ust.fitModel2D or ust.fitModel
        return pipe.new
            * func.map2({arcCoords[1], arcCoords[#arcCoords]}, {#allArcs[1] == 2, #allArcs[#allArcs] == 2}, function(c, t) return t and c end)
            * pipe.filter(pipe.noop())
            * pipe.mapi(sizeBuilder)
            * pipe.mapi(function(sizes, i)
                return sizes
                    * pipe.filter(pipe.noop())
                    * pipe.mapi(function(sizes, i)
                        local isLeftmost = i == 0
                        return func.map2({"platform_access_t_upper", "platform_access_t_lower"}, sizes, function(s, size)
                            return {
                                station.newModel(s .. (isLeftmost and "_br.mdl" or "_bl.mdl"),
                                    coor.transZ(-1.93) * coor.scaleZ(platformZ / 1.93) * coor.transZ(1.93), tZ,
                                    fitModel(3.75, 5, platformZ, size, false, not isLeftmost)
                                ),
                                station.newModel(s .. (isLeftmost and "_tl.mdl" or "_tr.mdl"),
                                    coor.transZ(-1.93) * coor.scaleZ(platformZ / 1.93) * coor.transZ(1.93), tZ,
                                    fitModel(3.75, 5, platformZ, size, true, isLeftmost)
                            )
                            }
                        end)
                    end)
            end)
            * pipe.flatten()
            * pipe.flatten()
            * pipe.flatten()
    end
    
    local terrainBuilder = function()
        return pipe.new
            / {
                equal = pipe.new
                * func.map2({arcCoords[1], arcCoords[#arcCoords]}, {#allArcs[1] == 2, #allArcs[#allArcs] == 2}, function(c, t) return t and c end)
                * pipe.filter(pipe.noop())
                * pipe.mapi(sizeBuilder)
                * pipe.mapi(function(sizes, i)
                    return sizes
                        * pipe.filter(pipe.noop())
                        * pipe.mapi(function(sizes, i)
                            local isLeftmost = i == 0
                            return func.map(sizes, function(size)
                                return pipe.new / size.lt:withZ(0) / size.lb:withZ(0) / size.rb:withZ(0) / size.rt:withZ(0) * station.finalizePoly
                            end)
                        end)
                end)
                * pipe.flatten()
                * pipe.flatten()
            }
    end
    
    local streetBuilder = function()
        local tZ = coor.transZ(-config.hPlatform - 0.53)
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local ac = p.access
                local pl = p.platform
                
                local outer, inner = i == 1 and ac.lc or ac.rc, i == 1 and pl.lc or pl.rc
                
                return {
                    i > 1 and {
                        pt = outer[ac.c + 1] .. tZ,
                        vec = (outer[ac.c + 1] - inner[pl.c + 1]):withZ(0):normalized()},
                    p.hasUpper and {
                        pt = outer[ac.c + 4 + floor(ac.c * 0.5)] .. tZ,
                        vec = (outer[pl.c + 4 + floor(pl.c * 0.5)] - inner[ac.c + 4 + floor(ac.c * 0.5)]):withZ(0):normalized()},
                    p.hasLower and {
                        pt = outer[ac.c - 4 - floor(ac.c * 0.5)] .. tZ,
                        vec = (outer[pl.c - 4 - floor(pl.c * 0.5)] - inner[ac.c - 4 - floor(ac.c * 0.5)]):withZ(0):normalized()}
                }
            end)
            * pipe.flatten()
            * pipe.filter(pipe.noop())
            * pipe.map(function(l)
                return {
                    edge = pipe.new / {l.pt, l.pt + l.vec * 10, l.vec, l.vec},
                    snap = pipe.new / {false, true}
                }
            end)
            * function(ls) return {pipe.new
                * {ls * station.mergeEdges}
                * station.prepareEdges
                * pipe.with({
                    type = "STREET",
                    params =
                    {
                        type = "station_entry.lua",
                        tramTrackType = "NO"
                    }
                }
            )
            }
            end
    end
    
    local laneBuilder = function()
        local transZ = coor.transZ(-config.hPlatform - 0.53 - 7.5)
        return pipe.new
            * func.map2({arcCoords[1], arcCoords[#arcCoords]}, {#allArcs[1] == 2, #allArcs[#allArcs] == 2}, function(c, t) return t and c end)
            * pipe.filter(pipe.noop())
            * pipe.mapi(function(p, i)
                local su = p.surface
                local la = p.lane
                local ac = p.access
                local pl = p.platform
                local l = i == 1 and su.lc or su.rc
                local r = i == 1 and la.lc or la.rc
                local s = i == 1 and ac.lc or ac.rc
                local t = i == 1 and pl.lc or pl.rc
                local fsuc, flac, facc, fplc = floor(su.c * 0.5), floor(la.c * 0.5), floor(ac.c * 0.5), floor(pl.c * 0.5)
                
                return pipe.new
                    / (i > 1 and {
                        ac = l[su.c]:avg(l[su.c + 1]):avg(l[su.c]),
                        pt = {
                            r[la.c],
                            r[la.c + 1]:avg(r[la.c])
                        },
                        st = {
                            e = s[ac.c + 1] / 6 + s[ac.c + 2] / 2 + t[pl.c + 1] / 12 + t[pl.c + 2] / 4,
                            pt = s[ac.c + 1],
                            vec = (s[ac.c + 1] - l[su.c + 1]):withZ(0):normalized()
                        }
                    })
                    / (p.hasUpper and {
                        ac = l[su.c + 4 + fsuc]:avg(l[su.c + 3 + fsuc]):avg(l[su.c + 3 + fsuc]),
                        pt = {
                            r[la.c + 2 + flac],
                            r[la.c + 1 + flac]:avg(r[la.c + 2 + flac])
                        },
                        st = {
                            e = s[ac.c + 4 + facc] / 6 + s[ac.c + 5 + facc] / 2 + t[pl.c + 4 + fplc] / 12 + t[pl.c + 5 + fplc] / 4,
                            pt = s[ac.c + 4 + facc],
                            vec = (s[ac.c + 4 + facc] - l[su.c + 4 + fsuc]):withZ(0):normalized()
                        }
                    })
                    / (p.hasLower and {
                        ac = l[su.c - 4 - fsuc]:avg(l[su.c - 3 - fsuc]):avg(l[su.c - 3 - fsuc]),
                        pt = {
                            r[la.c - 2 - flac],
                            r[la.c - 1 - flac]:avg(r[la.c - 2 - flac])
                        },
                        st = {
                            e = s[ac.c - 4 - facc] / 6 + s[ac.c - 5 - facc] / 2 + t[pl.c - 4 - fplc] / 12 + t[pl.c - 5 - fplc] / 4,
                            pt = s[ac.c - 4 - facc],
                            vec = (s[ac.c - 4 - facc] - l[su.c - 4 - fsuc]):withZ(0):normalized()
                        }
                    })
            end)
            * pipe.mapi(function(sizes, i)
                return sizes
                    * pipe.filter(pipe.noop())
                    * pipe.mapi(function(sizes, i)
                        local isLeftmost = i == 0
                        return func.map(sizes.pt, function(p)
                            return station.newModel("person_lane.mdl", ust.mRot(sizes.ac - p), coor.trans(p))
                        end)
                    end)
                    +
                    sizes
                    * pipe.filter(pipe.noop())
                    * pipe.mapi(function(sizes, i)
                        local p = sizes.st.pt .. coor.transZ(-config.hPlatform - 0.53)
                        local e = sizes.st.e .. coor.transZ(-config.hPlatform - 0.53 + 0.05)
                        local v = sizes.st.vec
                        local pt1 = p + (v .. coor.rotZ(0.5 * pi)) * 3
                        local pt2 = p + (v .. coor.rotZ(-0.5 * pi)) * 3
                        return {
                            station.newModel("person_lane.mdl", ust.mRot(e - pt1), coor.trans(pt1)),
                            station.newModel("person_lane.mdl", ust.mRot(e - pt2), coor.trans(pt2))
                        }
                    end)
            end)
            * pipe.flatten()
            * pipe.flatten()
    end
    
    return {
        access = accessBuilder(),
        lane = laneBuilder(),
        terrain = terrainBuilder(),
        street =  streetBuilder()
    }
end

local buildEntry = function(config, entryConfig)
    local allArcs = entryConfig.allArcs
    local arcCoords = entryConfig.arcCoords
    
    local function retriveRef()
        local pl, la = arcCoords[1].platform, arcCoords[1].lane
        local lc, rc, c = ust.bitLatCoords(5)(la.l, la.r)
        
        if (entryConfig.main.pos == 0 or not entryConfig.main.model) then
            local refPt = lc[c]
            return refPt,
                la.l[1]:rad(refPt) - la.l[1]:rad(lc[c]),
                rc[c],
                pl.lc[pl.c]:avg(pl.rc[pl.c])
        elseif (entryConfig.main.pos > 0) then
            local refPt = lc[floor(c * 0.6)]
            return refPt,
                la.l[1]:rad(refPt) - la.l[1]:rad(lc[c]),
                rc[floor(c * 0.6)],
                pl.lc[pl.c - 3 - floor(pl.c * 0.5)]:avg(pl.rc[pl.c - 3 - floor(pl.c * 0.5)])
        else
            local refPt = lc[ceil(c * 1.4)]
            return refPt,
                la.l[2]:rad(refPt) - la.l[1]:rad(lc[c]),
                rc[ceil(c * 1.4)],
                pl.lc[pl.c + 3 + floor(pl.c * 0.5)]:avg(pl.rc[pl.c + 3 + floor(pl.c * 0.5)])
        end
    end
    
    local refPt, refVec, cpt, cupt = retriveRef()
    
    local laneBuilder = function()
        return arcCoords
            * pipe.map(function(p)
                local pl, la = p.platform, p.lane
                local flac = floor(la.c * 0.5)
                local fplc = floor(pl.c * 0.5)
                return pipe.new
                    / ust.unitLane(la.lc[la.c - 2], pl.lc[pl.c - 4]:avg(pl.rc[pl.c - 4]))
                    / ust.unitLane(la.rc[la.c - 2], pl.lc[pl.c - 4]:avg(pl.rc[pl.c - 4]))
                    / ust.unitLane(la.lc[la.c + 2], pl.lc[pl.c + 4]:avg(pl.rc[pl.c + 4]))
                    / ust.unitLane(la.rc[la.c + 2], pl.lc[pl.c + 4]:avg(pl.rc[pl.c + 4]))
                    +
                    (p.hasLower and {
                        ust.unitLane(la.lc[la.c - 3]:avg(la.rc[la.c - 3], la.rc[la.c - 2], la.lc[la.c - 2]), pl.lc[pl.c - 4]:avg(pl.rc[pl.c - 4])),
                        ust.unitLane(la.lc[la.c - 2 - flac], pl.lc[pl.c - 4 - fplc]:avg(pl.rc[pl.c - 4 - fplc])),
                        ust.unitLane(la.rc[la.c - 2 - flac], pl.lc[pl.c - 4 - fplc]:avg(pl.rc[pl.c - 4 - fplc])),
                    } or {})
                    +
                    (p.hasUpper and {
                        ust.unitLane(la.lc[la.c + 3]:avg(la.rc[la.c + 3], la.rc[la.c + 2], la.lc[la.c + 2]), pl.lc[pl.c + 4]:avg(pl.rc[pl.c + 4])),
                        ust.unitLane(la.lc[la.c + 2 + flac], pl.lc[pl.c + 4 + fplc]:avg(pl.rc[pl.c + 4 + fplc])),
                        ust.unitLane(la.rc[la.c + 2 + flac], pl.lc[pl.c + 4 + fplc]:avg(pl.rc[pl.c + 4 + fplc]))
                    } or {})
                    + func.map2(il(func.range(pl.lc, pl.c - 3, pl.c + 3)), il(func.range(pl.rc, pl.c - 3, pl.c + 3)), function(lc, rc)
                        local b = lc.i:avg(rc.i)
                        local t = lc.s:avg(rc.s)
                        local vec = t - b
                        return station.newModel("person_lane.mdl", ust.mRot(vec), coor.trans(b), coor.transZ(-3.5))
                    end)
            end)
            * pipe.flatten()
            +
            arcCoords
            * pipe.map(function(p)
                local pl, la = p.platform, p.lane
                local fplc = floor(pl.c * 0.5)
                return pipe.new
                    / (pl.lc[pl.c]:avg(pl.rc[pl.c]) + coor.xyz(0, 0, -3.5))
                    + (p.hasUpper and {pl.lc[pl.c + 3 + fplc]:avg(pl.rc[pl.c + 3 + fplc]) - coor.xyz(0, 0, 3.5)} or {})
                    + (p.hasLower and {pl.lc[pl.c - 3 - fplc]:avg(pl.rc[pl.c - 3 - fplc]) - coor.xyz(0, 0, 3.5)} or {})
            end)
            * pipe.interlace({"l", "r"})
            * pipe.map(function(p)
                return pipe.mapn(p.l, p.r)(function(pt, nPt)
                    return station.newModel("person_lane.mdl", ust.mRot((nPt - pt)), coor.trans(pt))
                end)
            end)
            * pipe.flatten()
    end
    
    local accessBuilder = function()
        local mx = coor.transX(-config.buildingParams.xOffset) * coor.rotZ(refVec) * coor.trans(refPt)
        local m = coor.rotX(atan(-config.slope)) * mx
        return
            pipe.new
            * func.map(config.buildingParams.platform, function(p) return ust.unitLane(p .. m, cpt) end)
            + func.map(config.buildingParams.entry, function(p) return ust.unitLane(p .. m, coor.xyz(-10, p.y > 0 and 4.5 or -4.5, -0.8) .. mx) end)
            + func.map(config.buildingParams.pass, function(p) return ust.unitLane(p .. m, cupt - coor.xyz(0, 0, 3.5)) end)
            + {station.newModel(entryConfig.main.model, coor.rotZ(-pi * 0.5), m, coor.transZ(-0.78))}
    end
    
    local streetBuilder = function()
        local mVe = coor.rotZ(refVec)
        local mPt = coor.transX(-config.buildingParams.xOffset) * mVe * coor.trans(refPt)
        local mainAccess = {
            edge = pipe.new / {
            (config.buildingParams.street .. mPt):withZ(refPt.z - 0.8),
                ((config.buildingParams.street - coor.xyz(20, 0, 0)) .. mPt):withZ(refPt.z - 0.8),
                coor.xyz(-1, 0, 0) .. mVe,
                coor.xyz(-1, 0, 0) .. mVe
            },
            snap = pipe.new / {false, true}
        }
        
        return pipe.new
            / (pipe.new
            * {mainAccess}
            * station.prepareEdges
            * pipe.with(
                {
                    type = "STREET",
                    params =
                    {
                        type = "station_new_small.lua",
                        tramTrackType = "NO"
                    }
                })
    )
    end
    
    local terrainBuilder = function()
        local z = -0.8
        local mRot = coor.rotX(atan(-config.slope))
        local mX = coor.transX(-config.buildingParams.xOffset) * coor.rotZ(refVec) * coor.trans(refPt)
        local xMin = config.buildingParams.street.x
        local xMax = config.buildingParams.xOffset
        local yMin = -config.buildingParams.halfWidth
        local yMax = config.buildingParams.halfWidth
        return pipe.new / {
            equal = pipe.new
            / {
                coor.xyz(config.buildingParams.entry[1].x, yMin, z) .. mRot * mX,
                coor.xyz(xMax, yMin, z) .. mRot * mX,
                coor.xyz(xMax, yMax, z) .. mRot * mX,
                coor.xyz(config.buildingParams.entry[1].x, yMax, z) .. mRot * mX
            }
            / {
                coor.xyz(config.buildingParams.street.x, yMin, z) .. mX,
                coor.xyz(config.buildingParams.entry[1].x, yMin, z) .. mRot * mX,
                coor.xyz(config.buildingParams.entry[1].x, yMax, z) .. mRot * mX,
                coor.xyz(config.buildingParams.street.x, yMax, z) .. mX
            }
            * pipe.map(station.finalizePoly)
        }
    end
    
    local hasMain = entryConfig.main.model
    
    return {
        access = hasMain and accessBuilder() or {},
        lane = hasMain and laneBuilder() or {},
        terrain = hasMain and terrainBuilder() or {},
        street = hasMain and streetBuilder() or {}
    }
end

local buildStation = function(totalTracks, arcPacker, config, ignoreFst, ignoreLst)
    local pW = config.wPlatform
    local tW = config.wTrack
    local bandWidth = 0.8
    local pWe = config.wExtPlatform * (pW - bandWidth * 2) + bandWidth * 2
    local fitModel = slope == 0 and ust.fitModel2D or ust.fitModel
    local generateEdges = ust.generateEdges
    local generateModels = ust.generateModels(fitModel, config)
    local generateFences = ust.generateFences(fitModel, config)
    local generateTerminals = ust.generateTerminals(config)
    local generateTerrain = ust.generateTerrain(config)
    
    local function preBuild(nbTracks, result)
        local p = false
        local t = true
        local transitSeq = pipe.new * pipe.rep(config.nbTransitTracks)(t)
        if (nbTracks == 0) then
            if (#transitSeq > 0) then
                if (config.posTransitTracks == -2) then
                    result = transitSeq + result
                elseif (config.posTransitTracks == 1) then
                    result = result + transitSeq
                elseif (config.posTransitTracks == 0) then
                    result = pipe.new * pipe.rep(ceil(config.nbTransitTracks * 0.5))(t) + result + pipe.new * pipe.rep(floor(config.nbTransitTracks * 0.5))(t)
                else
                    local idx = result * pipe.zip(func.seq(1, #result), {"t", "i"}) * pipe.filter(function(p) return not p.t end) * pipe.map(pipe.select("i"))
                    result = result * pipe.range(1, idx[ceil(#idx * 0.5)]) + transitSeq + result * pipe.range(idx[ceil(#idx * 0.5)] + 1, #result)
                end
            end
            return result
        elseif (nbTracks == totalTracks and (not ignoreFst or totalTracks == 1)) then
            return preBuild(nbTracks - 1, result / p / t)
        elseif (nbTracks == 1 and ignoreLst) then
            return preBuild(nbTracks - 1, result / p / t)
        elseif (nbTracks == 1 and not ignoreLst) then
            return preBuild(nbTracks - 1, result / t / p)
        else
            return preBuild(nbTracks - 2, result / t / p / t)
        end
    end
    
    local ptList = preBuild(totalTracks, pipe.new)
    local ptListI = ptList * pipe.zip(func.seq(1, #ptList), {"t", "i"})
    local refList = ptListI
        * pipe.filter(function(x) return config.varRefIsTrack and x.t or not x.t end)
        * pipe.map(pipe.select("i"))
        * pipe.sort(function(x, y) return x < y end)
    local middlePos =
        config.varRefPos < 0 and refList[1]
        or config.varRefPos > 0 and refList[#refList]
        or #refList % 2 == 1 and refList[(#refList + 1) * 0.5] or refList[#refList * 0.5]
    
    local leftGroup = ptListI * pipe.filter(function(p) return p.i < middlePos end) * pipe.rev()
    local middleGroup = ptListI * pipe.filter(function(p) return p.i == middlePos end)
    local rightGroup = ptListI * pipe.filter(function(p) return p.i > middlePos end)
    
    local function platformArcGen(r, o, lPct, oPct, pWe, isRight)
        local rInner = r - (isRight and 1 or -1) * (0.5 * tW)
        local rOuter = r - (isRight and 1 or -1) * (0.5 * tW + pW)
        local inner = arcPacker(rInner, o, lPct, oPct)
        local li, ls = table.unpack(inner()()())
        local ri, rs = table.unpack(arcPacker(rOuter, o, lPct, oPct * (rOuter / rInner))()()())
        local mlpt = li:pt(li.inf)
        local mrpt = ri:pt(ri.inf)
        
        local mvec = (mrpt - mlpt):normalized()
        local f = mvec:dot(mlpt - li.o) > 0 and 1 or -1
        
        local elpt = li:pt(li.sup)
        local erpt = (elpt - li.o):normalized() * f * pWe + elpt
        
        local mln = line.byVecPt(mvec, mrpt)
        local pln = line.byVecPt(mvec .. coor.rotZ(pi * 0.5), erpt)
        local xpt = (mln - pln):withZ(0)
        
        local rvec = (xpt - mrpt):dot(xpt - li.o) * rInner
        
        local lenP2 = (xpt - erpt):length2()
        local lenT = (xpt - mrpt):length()
        local r = (lenP2 / lenT + lenT) * 0.5 * (rvec < 0 and 1 or -1)
        
        local o = mrpt + (xpt - mrpt):normalized() * abs(r)
        
        return r + 0.5 * tW * (isRight and 1 or -1), o, {
            isRight and inner or arcPacker(r, o, lPct, oPct * (r / rInner)),
            isRight and arcPacker(r, o, lPct, oPct * (r / rInner)) or inner
        }
    end
    
    local function generateArcs(init, initDr, initX)
        local varFn = function(base) return
            {
                function(_) return 1 end,
                function(x) return x end,
                function(x) return x * x end,
                function(x) return pow(x, 4) end,
                function(x) return 1 - pow(e, -x * x * 4.5) end,
                function(x) return pow(e, -pow(6 * x - 3, 2) * 0.5) end,
            }
        end
        
        local lengthFn = function(posPct) return 1 - (1 - config.lExtPlatform) * varFn(config.lExtPlatform)[config.varModelLength](posPct) end
        local widthFn = function(posPct) return (1 - (1 - config.wExtPlatform) * varFn(config.wExtPlatform)[config.varModelWidth](posPct)) * (pW - bandWidth * 2) + bandWidth * 2 end
        
        local function arcGen(result, r, o, isRight)
            return isRight
                and function(t, ...)
                    if t == nil then
                        return result * pipe.sort(function(l, r) return l.i < r.i end) * pipe.map(pipe.select("a"))
                    else
                        local posPct = abs(t.i - middlePos) / (#rightGroup)
                        local isVar = posPct > config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and -posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPacker(r - tW, o, isVar and lengthPct or 1, offsetPct)}},
                                r - tW, o, true)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(result / {
                                    i = t.i,
                                    a = {
                                        arcPacker(r - (0.5 * tW), o, lengthPct, offsetPct),
                                        arcPacker(r - (0.5 * tW + pW), o, lengthPct, offsetPct)
                                    }},
                                r - pW, o, true)(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local r, o, a = platformArcGen(r, o, lengthPct, offsetPct, pWe, true)
                                return arcGen(result / {i = t.i, a = a},
                                    r, o, true)(...)
                            end
                        end
                    end
                end
                or function(t, ...)
                    if t == nil then
                        return arcGen(result, initDr[#initDr], initX, true)(table.unpack(rightGroup))
                    else
                        local posPct = abs(t.i - middlePos) / (#leftGroup)
                        local isVar = posPct > config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPacker(r + tW, o, lengthPct, offsetPct)}},
                                r + tW, o)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(result / {
                                    i = t.i,
                                    a = {
                                        arcPacker(r + (0.5 * tW + pW), o, lengthPct, offsetPct),
                                        arcPacker(r + (0.5 * tW), o, lengthPct, offsetPct)
                                    }},
                                r + pW, o)(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local r, o, a = platformArcGen(r, o, lengthPct, offsetPct, pWe, false)
                                return arcGen(result / {i = t.i, a = a},
                                    r, o)(...)
                            end
                        end
                    end
                end
        end
        local rs = arcGen(pipe.new / init, initDr[1], initX)(table.unpack(leftGroup))
        return rs
    end
    
    local allArcs = pipe.exec * function()
        local o = coor.xyz(config.r, 0, 0)
        if table.unpack(middleGroup).t then
            return generateArcs(
                {
                    i = middlePos,
                    a = {arcPacker(config.r, o)}
                },
                {config.r}, o
        ) else
            return generateArcs(
                {
                    i = middlePos,
                    a = {
                        arcPacker(config.r + 0.5 * pW, o),
                        arcPacker(config.r - 0.5 * pW, o)
                    }
                },
                {
                    config.r - (-0.5 * pW + 0.5 * tW),
                    config.r - (0.5 * pW - 0.5 * tW)
                }, o
        ) end
    end
    
    local entryConfig = func.with(config.entries, {
        allArcs = allArcs,
        arcCoords = pipe.exec * function()
            local refZ = config.hPlatform + 0.53
            return allArcs
                * pipe.filter(function(a) return #a == 2 end)
                * pipe.map(function(p)
                    local arcL, arcR = table.unpack(p)
                    local l, r = arcL(refZ)(function(l) return l - 3 end)(1), arcR(refZ)(function(l) return l - 3 end)(-1)
                    local ls, rs = arcL(refZ)()(-0.5), arcR(refZ)()(0.5)
                    local lsu, rsu = arcL(refZ)()(0.3), arcR(refZ)()(-0.3)
                    local la, ra = arcL(refZ)()(-4.25), arcR(refZ)()(4.25)
                    local lc, rc, c = ust.bitLatCoords(10)(l, r)
                    local lsc, rsc, lac, rac, lsuc, rsuc, sc = ust.bitLatCoords(5)(ls, rs, la, ra, lsu, rsu)
                    return {
                        lane = {l = l, r = r, lc = lc, rc = rc, c = c},
                        platform = {l = ls, r = rs, lc = lsc, rc = rsc, c = sc},
                        access = {l = la, r = ra, lc = lac, rc = rac, c = sc},
                        surface = {l = lsu, r = rsu, lc = lsuc, rc = rsuc, c = sc},
                        hasLower = c - 2 - floor(c * 0.5) > 0 and c - 3 > 0,
                        hasUpper = c + 2 + floor(c * 0.5) <= #lc and c + 3 <= #lc
                    }
                end)
        end
    })
    
    local entry1 = buildEntry(config, entryConfig)
    local entry2 = buildUndergroundEntry(config, entryConfig)

    local function build(edges, terminals, terminalsGroup, models, terrain, gr, ...)
        local isLeftmost = #models == 0
        local isRightmost = #{...} == 0
        if (gr == nil) then
            local buildEntryPath = entry1.access + entry2.access
            local buildFace = entry1.terrain + entry2.terrain
            local buildAccessRoad = entry1.street + entry2.street
            local buildLanes = entry1.lane + entry2.lane
            -- local buildEntryPath, buildFace, buildLanes, buildAccessRoad = buildEntry(config, allArcs)
            return edges, buildAccessRoad, terminals, terminalsGroup,
                models + buildEntryPath + buildLanes,
                terrain + buildFace --+ streetFaces
        elseif (#gr == 3) then
            edges = generateEdges(edges, true, gr[1][1])
            edges = generateEdges(edges, false, gr[3][1])
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, gr[2][1], gr[2][2], {true, true})
            return build(
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(gr[2][1], gr[2][2], isLeftmost and -1 or isRightmost and 1 or 0)
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], gr[1][1], true, true) or {})
                + (config.rightFences and isRightmost and generateFences(gr[3][1], gr[3][1], false, true) or {}),
                terrain + generateTerrain(gr[2][1], gr[2][2], isLeftmost and -1 or isRightmost and 1 or 0),
                ...)
        elseif (#gr == 2 and #gr[1] == 1 and #gr[2] == 2) then
            edges = generateEdges(edges, true, gr[1][1])
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, gr[2][1], gr[2][2], {true, false})
            return build(
                edges,
                terminals,
                terminalsGroup,
                models
                + generateModels(gr[2][1], gr[2][2], isLeftmost and -1 or isRightmost and 1 or 0)
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], gr[1][1], true, true) or {})
                + (config.rightFences and isRightmost and generateFences(gr[2][2], gr[2][2], false, false) or {}),
                terrain + generateTerrain(gr[2][1], gr[2][2], isLeftmost and -1 or isRightmost and 1 or 0),
                ...)
        elseif (#gr == 2 and #gr[1] == 2 and #gr[2] == 1) then
            edges = generateEdges(edges, false, gr[2][1])
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, gr[1][1], gr[1][2], {false, true})
            return build(edges,
                terminals,
                terminalsGroup,
                models
                + generateModels(gr[1][1], gr[1][2], isLeftmost and -1 or isRightmost and 1 or 0)
                + (config.leftFences and isLeftmost and generateFences(gr[1][1], gr[1][1], true, false) or {})
                + (config.rightFences and isRightmost and generateFences(gr[2][1], gr[2][1], false, true) or {}),
                terrain + generateTerrain(gr[1][1], gr[1][2], isLeftmost and -1 or isRightmost and 1 or 0),
                ...)
        else
            edges = generateEdges(edges, false, gr[1][1])
            return build(edges,
                terminals,
                terminalsGroup,
                models,
                terrain,
                ...)
        end
    end
    
    return build(pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, trackGrouping(pipe.new, table.unpack(allArcs)))
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = wPlatformList[params.wPlatform + 1]
        local roofLength = roofLengthList[params.roofLength + 1] * 0.01
        local mainBuilding = params.entrySize > 0 and buildingList[params.entrySize]
        local fencesLength = fencesLengthList[params.fencesStyle + 1]
        local fencesModel = {
            "fences/" .. tostring(params.fencesColor + 1) .. "/platform_fences_" .. tostring(params.fencesStyle + 1) .. ".mdl",
            "fences/" .. tostring(params.fencesColor + 1) .. "/platform_fences_pole_" .. tostring(params.fencesStyle + 1) .. ".mdl",
        }
        
        
        local nbTracks = trackNumberList[params.nbTracks + 1]
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local slope = slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local length = min(trackLengths[params.length + 1], abs(radius * pi * 1.5))
        
        local entryConfig = {
            main = {
                pos = mainBuilding and (params.entryPos - 1),
                model = mainBuilding,
            },
            street = {
                left = func.mapi({params.entryAType == 1, params.entryBType == 1, params.entryCType == 1}, function(t, i) return t and not (mainBuilding and params.entryPos + 1 == i) end),
                right = {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1}
            },
            underground = {
                left = func.mapi({params.entryAType == 0, params.entryBType == 0, params.entryCType == 0}, function(t, i) return t and not (mainBuilding and params.entryPos + 1 == i) end),
                right = {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0}
            }
        }
        
        
        local edge, streetEdge, terminals, terminalsGroup, models, terrain =
            buildStation(nbTracks,
                ust.arcPacker(length, slope),
                {
                    nbTransitTracks = params.nbTransitTracks,
                    posTransitTracks = params.posTransitTracks - 2,
                    r = radius,
                    hPlatform = hPlatform,
                    wPlatform = wPlatform,
                    wExtPlatform = extWidthList[params.wExtPlatform + 1] * 0.01,
                    lExtPlatform = extLengthList[params.lExtPlatform + 1] * 0.01,
                    yOffsetPlatform = yOffsetList[params.yOffsetPlatform + 1] * (params.yOffsetPlatformSign == 0 and 0.01 or -0.01),
                    varRefPos = params.varRefPos - 1,
                    varRefIsTrack = params.varRefType == 0,
                    varNbUnaffected = varUnaffectedList[params.varNbUnaffected + 1] * 0.01,
                    varModelLength = params.varModelLength + 1,
                    varModelWidth = params.varModelWidth + 1,
                    wTrack = 5,
                    roofLength = roofLength,
                    buildingParams = buildingParamsList[params.entrySize + 1],
                    slope = slope,
                    fencesModel = fencesModel,
                    fencesLength = fencesLength,
                    leftFences = params.fencesPos == 1 or params.fencesPos == 3,
                    rightFences = params.fencesPos == 2 or params.fencesPos == 3,
                    entries = entryConfig
                },
                ({true, false, true, false})[params.trackLayout + 1],
                (nbTracks % 2 == 0 and {false, false, true, true} or {true, true, false, false})[params.trackLayout + 1]
        )
        return
            pipe.new
            * {
                edgeLists = pipe.new
                / (pipe.new * {edge * station.mergeEdges} * station.prepareEdges * trackBuilder.normal())
                + streetEdge,
                models = terminals + models,
                terminalGroups = terminalsGroup,
                terrainAlignmentLists = station.mergePoly(table.unpack(terrain))(),
                groundFaces = terrain
                * pipe.map(pipe.select("equal"))
                * pipe.flatten()
                * pipe.map(function(f) return {
                    {face = f, modes = {{type = "FILL", key = "industry_gravel_small_01"}}},
                    {face = f, modes = {{type = "STROKE_OUTER", key = "building_paving"}}}
                } end)
                * pipe.flatten()
            }
    end
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 27218,
        params = params(),
        updateFn = updateFn()
    }
end
