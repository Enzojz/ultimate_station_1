local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local pipe = require "ustation/pipe"
local ust = require "ustation"

local dump = require "datadumper"

local abs = math.abs
local ceil = math.ceil
local floor = math.floor
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {ust.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local wPlatformList = {4, 5, 6, 7, 8}
local roofLengthList = {100, 95, 80, 75, 50, 25, 0}

local buildingList = {
    "main_building_size1.mdl",
    "main_building_size2.mdl",
    "main_building_size3.mdl",
    "main_building_size4.mdl",
    "main_building_size5.mdl",
}

local platformSegments = {2, 4, 8, 12, 16, 20, 24}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 12}
local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "length",
            name = _("Platform length") .. "(m)",
            values = func.map(platformSegments, function(l) return _(tostring(l * station.segmentLength)) end),
            defaultIndex = 2
        },
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "trackLayout",
            name = _("Track Layout"),
            values = func.map({1, 2, 3, 4}, tostring),
            defaultIndex = 0
        },
        {
            key = "sign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "hPlatform",
            name = sp .. "\n" .. _("Platform") .. "\n" .. _("Height") .. "(mm)",
            values = func.map(hPlatformList, tostring),
            defaultIndex = 3
        },
        {
            key = "wPlatform",
            name = _("Width") .. "(m)",
            values = func.map(wPlatformList, tostring),
            defaultIndex = 1
        },
        {
            key = "roofLength",
            name = _("Roof length") .. "(%)",
            values = func.map(roofLengthList, tostring),
            defaultIndex = 3
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "entrySize",
            name = _("Entry"),
            values = {"XS", "S", "M", "L", "XL"},
            defaultIndex = 1
        }
    
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    param.trackType = param.trackType or 0
    param.catenary = param.catenary or 0
    
    func.forEach(
        func.filter(params({}), function(p) return p.key ~= "tramTrack" end),
        function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)

end


local rBuild = function(totalTracks, baseX, arcPacker, fitModel, hPlatform, wPlatform, roofLength, ignoreFst, ignoreLst)
    local pW = wPlatform
    local tW = 5
    local generateEdges = ust.generateEdges(arcPacker()())
    local generateModels = ust.generateModels(arcPacker, fitModel, hPlatform, roofLength)
    local generateTerminals = ust.generateTerminals(arcPacker, hPlatform)
    local generateTerrain = ust.generateTerrain(arcPacker())
    local tOffset = function(po) return {po[1] + 1, po[2] - 1} end

    local buildEntryPath = function()
        return {
            ust.unitLane(coor.xyz(-5, 0, 0), coor.xyz(baseX + 0.5 * pW - 1, 0, hPlatform + 0.53)),
            ust.unitLane(coor.xyz(-1, 0, hPlatform - 3.5 + 0.53), coor.xyz(-5, 0, 0)),
            ust.unitLane(coor.xyz(-5, 0, 0), coor.xyz(-10, 2.5, 0)),
            ust.unitLane(coor.xyz(-5, 0, 0), coor.xyz(-10, -2.5, 0)),
        }
    end
    

    local function build(nbTracks, baseX, incrX, edges, terminals, terminalsGroup, models, terrain, ptCon)
        if (nbTracks == 0) then
            return edges, terminals, terminalsGroup, models + buildEntryPath(), terrain
        elseif (nbTracks == totalTracks and (not ignoreFst or totalTracks == 1)) then
            local edgeBase = baseX + 0.5 * tW + 0.5 * pW
            local edgeOffset = 0
            local platformBase = {edgeBase, edgeBase}
            local platformOffset = {-0.5 * tW - pW, -0.5 * tW}
            edges = generateEdges(edges, false, edgeBase)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true}, ptCon)
            return build(nbTracks - 1, edgeBase, tW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset, true),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        elseif (nbTracks == 1 and ignoreLst) then
            local edgeBase = baseX + incrX + 0.5 * tW + 0.5 * pW
            local edgeOffset = 0
            local platformBase = {baseX, edgeBase}
            local platformOffset = {0.5 * tW, -0.5 * tW}
            local terminalOffset = {platformOffset[1] + 1, platformOffset[2] - 1}
            edges = generateEdges(edges, false, edgeBase)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true}, ptCon)
            return build(nbTracks - 1, baseX, 1.5 * tW + 0.5 * pW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        elseif (nbTracks == 1 and not ignoreLst) then
            local edgeBase = baseX
            local edgeOffset = incrX
            local platformBase = {baseX, baseX + incrX}
            local platformOffset = {incrX + 0.5 * tW, 0.5 * tW + pW}
            edges = generateEdges(edges, true, edgeBase, edgeOffset)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, false}, ptCon)
            return build(nbTracks - 1, baseX, pW + 0.5 * tW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        else
            local platformBase = {baseX, baseX + incrX + tW + pW}
            local platformOffset = {incrX + 0.5 * tW, -0.5 * tW}
            edges = generateEdges(edges, true, baseX, incrX)
            edges = generateEdges(edges, false, baseX + incrX + tW + pW)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, true}, ptCon)
            return build(nbTracks - 2, baseX + incrX + tW + pW, tW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        end
    end
    return build(totalTracks, baseX, 0, pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, pipe.new / coor.xyz(-1, 0, hPlatform - 3.5 + 0.53))
end

local buildEntry = function(model, slope, hPlatform)
    return station.newModel(model, coor.xXY(), coor.transX(-6.5), coor.transZ(hPlatform - 0.25), coor.rotX(atan(-slope)))
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = wPlatformList[params.wPlatform + 1]
        local roofLength = roofLengthList[params.roofLength + 1] * 0.01
        local mainBuilding = buildingList[params.entrySize + 1]
        
        local nSeg = platformSegments[params.length + 1]
        local length = nSeg * station.segmentLength
        
        local nbTracks = trackNumberList[params.nbTracks + 1]
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local slope = slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local edge, terminals, terminalsGroup, models, terrain =
            rBuild(nbTracks, 0,
                ust.arcPacker(radius, incr, length, slope),
                slope == 0 and ust.fitModel2D or ust.fitModel,
                hPlatform, wPlatform, roofLength,
                ({true, false, true, false})[params.trackLayout + 1],
                (nbTracks % 2 == 0 and {false, false, true, true} or {true, true, false, false})[params.trackLayout + 1]
        )

        return
            pipe.new
            * {
                edgeLists = {pipe.new * {edge * (station.mergeEdges)} * station.prepareEdges * trackBuilder.normal()},
                models = terminals + models + {buildEntry(mainBuilding, slope, hPlatform)},
                terminalGroups = terminalsGroup,
                terrainAlignmentLists = {
                    {
                        type = "EQUAL",
                        faces = terrain,
                        slopeLow = 0.75,
                        slopeHigh = 2.5
                    }
                }
            }
    end
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 27218,
        params = params(),
        updateFn = updateFn()
    }
end
