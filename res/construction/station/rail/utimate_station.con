local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local line = require "ustation/coorline"
local arc = require "ustation/coorarc"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local pipe = require "ustation/pipe"
local ust = require "ustation"

local dump = require "datadumper"

local abs = math.abs
local ceil = math.ceil
local floor = math.floor
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {ust.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local wPlatformList = {4, 5, 6, 7, 8}

local platformSegments = {2, 4, 8, 12, 16, 20, 24}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 12}
local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "length",
            name = _("Platform length") .. "(m)",
            values = func.map(platformSegments, function(l) return _(tostring(l * station.segmentLength)) end),
            defaultIndex = 2
        },
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "trackLayout",
            name = _("Track Layout"),
            values = func.map({1, 2, 3, 4}, tostring),
            defaultIndex = 0
        },
        {
            key = "sign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "hPlatform",
            name = _("Platform Height") .. "(mm)",
            values = func.map(hPlatformList, tostring),
            defaultIndex = 3
        },
        {
            key = "wPlatform",
            name = _("Platform Width") .. "(m)",
            values = func.map(wPlatformList, tostring),
            defaultIndex = 1
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
    
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    param.trackType = param.trackType or 0
    param.catenary = param.catenary or 0
    
    func.forEach(
        func.filter(params({}), function(p) return p.key ~= "tramTrack" end),
        function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)

end

local arcPacker = function(radius, incr, length, slope)
    local baseCenter = coor.xy(radius, 0)
    local initRad = radius > 0 and pi or 0
    return function(lengthOverride)
        local l = lengthOverride and lengthOverride(length) or length
        return function(x, dr)
            dr = dr or 0
            local ar = arc.byOR(baseCenter + coor.xy(x, 0), abs(radius - dr))
            local rad = (radius > 0 and 1 or -1) * l / ar.r * 0.25
            return pipe.new
                / ar:withLimits({
                    inf = initRad - rad * 2,
                    sup = initRad
                })
                / ar:withLimits({
                    inf = initRad,
                    sup = initRad + rad * 2
                }),
                function(rad) return (radius > 0 and 1 or -1) * ((initRad - rad) * ar.r) * slope end,
                function(rad) return -slope end
        end
    end
end

local function mPlace(guideline, rad1, rad2)
    local rad = rad2 and (rad1 + rad2) * 0.5 or rad1
    local z = 0
    local s = 0
    local pt = guideline:pt(rad)
    return coor.shearZoY(s) * coor.transZ(z) * coor.rotZ(rad) * coor.trans(func.with(pt, {z = 0}))
end

local mRot = function(vec)
    local nv = func.with(vec, {z = 0}):normalized()
    local sx = nv.y
    local cx = nv.x
    return coor.I() * {
        cx, sx, 0, 0,
        -sx, cx, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    }
end

local mRotZ = function(vec)
    local nv = func.with(vec, {y = 0}):normalized()
    local sx = nv.z
    local cx = nv.x
    return coor.I() * {
        cx, 0, sx, 0,
        0, 1, 0, 0,
        -sx, 0, cx, 0,
        0, 0, 0, 1
    } * (cx < 0 and coor.flipX() or coor.I())
end

local mShear = function(vec)
    local nv = vec:normalized()
    return coor.I() * {
        1, 0, 0, 0,
        nv.x / nv.y, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    }
end

local retriveBiLatCoords = function(length)
    return function(l, ...)
        local nSeg = (function(x) return (x < 1 or (x % 1 > 0.5)) and ceil(x) or floor(x) end)(l:length() / length)
        local rst = pipe.new * {l, ...}
        local lscale = l:length() / (nSeg * length)
        return rst * pipe.map(function(s) return abs(lscale) < 1e-5 and pipe.new * {} or pipe.new * func.seqMap({0, nSeg}, function(n) return s:pt(s.inf + n * ((s.sup - s.inf) / nSeg)) end) end)
    end
end

local equalizeArcs = function(...)
    local arcs = pipe.new * {...}
    local ptInf = func.fold(arcs, coor.xy(0, 0), function(p, ar) return p + ar:pt(ar.inf) end) / #arcs
    local ptSup = func.fold(arcs, coor.xy(0, 0), function(p, ar) return p + ar:pt(ar.sup) end) / #arcs
    return table.unpack(arcs * pipe.map(function(ar)
        return ar:withLimits({
            inf = ust.normalizeRad(ar:rad(ptInf)),
            sup = ust.normalizeRad(ar:rad(ptSup))
        }
    )
    end)
)
end

local fitModel = function(w, h, d, size, fitTop, fitLeft)
    local b = {
        coor.xyz(0, 0, d),
        coor.xyz(fitLeft and w or -w, 0, d),
        coor.xyz(0, fitTop and -h or h, d),
        coor.xyz(0, 0, 0)
    }
    
    local d = fitTop and
        {
            fitLeft and size.lt or size.rt,
            fitLeft and size.rt or size.lt,
            fitLeft and size.lb or size.rb,
            func.with(fitLeft and size.lt or size.rt, {z = 0})
        } or {
            fitLeft and size.lb or size.rb,
            fitLeft and size.rb or size.lb,
            fitLeft and size.lt or size.rt,
            func.with(fitLeft and size.lb or size.rb, {z = 0})
        }
    
    local mX = {
        {b[1].x, b[1].y, b[1].z, 1},
        {b[2].x, b[2].y, b[2].z, 1},
        {b[3].x, b[3].y, b[3].z, 1},
        {b[4].x, b[4].y, b[4].z, 1}
    }
    
    local mU = {
        d[1].x, d[1].y, d[1].z, 1,
        d[2].x, d[2].y, d[2].z, 1,
        d[3].x, d[3].y, d[3].z, 1,
        d[4].x, d[4].y, d[4].z, 1
    }
    
    local dX = coor.det(mX)
    
    local miX = coor.minor(mX)
    local mXI = func.mapFlatten(func.seq(1, 4),
        function(l)
            return func.seqMap({1, 4}, function(c)
                return ((l + c) % 2 == 0 and 1 or -1) * coor.det(miX(c, l)) / dX
            end)
        end)
    
    return coor.I() * mXI * mU
end

local bitLatCoords = function(l, r, length)
    local lcs1, rcs1 = table.unpack(retriveBiLatCoords(length)(equalizeArcs(l[1], r[1])))
    local lcs2, rcs2 = table.unpack(retriveBiLatCoords(length)(equalizeArcs(l[2], r[2])))
    return
        lcs1 * pipe.range(1, #lcs1 - 1) + {(lcs1[#lcs1] + lcs2[1]) * 0.5} + lcs2 * pipe.range(2, #lcs2),
        rcs1 * pipe.range(1, #rcs1 - 1) + {(rcs1[#rcs1] + rcs2[1]) * 0.5} + rcs2 * pipe.range(2, #rcs2),
        #lcs1
end

local stairs = function(tl, tr, p, tZ)
    local scl = tl:withZ(1.4 + 0.53)
    local scr = tr:withZ(1.4 + 0.53)
    local dc = p:withZ(1.4 + 0.53)
    return pipe.new
        / station.newModel("person_lane.mdl", coor.scaleX((dc - scl):length()), mRot(dc - scl), coor.trans(scl), tZ)
        / station.newModel("person_lane.mdl", coor.scaleX((dc - scr):length()), mRot(dc - scr), coor.trans(scr), tZ)
end

local generateEdges = function(arcPacker)
    return function(edges, isLeft, xOffset, xtOffset)
        local _, fz, fso = arcPacker()(xOffset, xtOffset)
        local fs = isLeft and function(p) return -fso(p) end or fso
        local arcs = arcPacker()(xOffset, xtOffset) * pipe.map(isLeft and arc.rev or pipe.noop()) * (isLeft and pipe.rev() or pipe.noop())
        return edges /
            {
                edge = arcs * pipe.map(ust.generateArc(fz, fs)) + (arcs * pipe.mapFlatten(ust.generateArcExt(fz, fs)) * function(ls) return {ls[1], ls[4]} end),
                snap = pipe.new / {false, false} / {false, false} / {true, false} / {false, true}
            }
    end
end

local generateTerminals = function(arcPacker, hPlatform)
    local tZ = coor.transZ(hPlatform - 1.4)
    local il = pipe.interlace({"i", "s"})
    return function(edges, terminals, terminalsGroup, xOffsets, uOffsets, enablers, ptCon)
        local l, r = table.unpack(func.map2(xOffsets, uOffsets, arcPacker(function(l) return l - 3 end)))
        local ls, rs = table.unpack(func.map2(xOffsets, uOffsets, arcPacker()))
        
        local lc, rc, c = bitLatCoords(l, r, 10)
        local lsc, rsc, sc = bitLatCoords(ls, rs, 5)
        
        local newPtCon = ((lsc[sc] + rsc[sc]) * 0.5):withZ(1.4 + 0.53 - 3.5 + hPlatform - 1.4)
        
        local newTerminals = pipe.new *
            pipe.mapn(il(lc), il(rc))(function(lc, rc)
                local lb = lc.i:withZ(1.4 + 0.53)
                local lt = lc.s:withZ(1.4 + 0.53)
                local rb = rc.i:withZ(1.4 + 0.53)
                local rt = rc.s:withZ(1.4 + 0.53)
                local vecl = (lt - lb)
                local vecr = (rb - rt)
                local vectl = (lt + lb) * 0.5 - (rt + rb) * 0.5
                return {
                    l = station.newModel("terminal_lane.mdl", coor.scaleX(vecl:length()), mRot(vecl), coor.trans(lb), tZ),
                    r = station.newModel("terminal_lane.mdl", coor.scaleX(vecr:length()), mRot(vecr), coor.trans(rt), tZ),
                    link = station.newModel("standard_lane.mdl", coor.scaleX(vectl:length()), mRot(vectl), coor.trans((rt + rb) * 0.5), tZ)
                }
            end)
            * function(ls)
                return pipe.new
                    / (enablers[1] and func.map(ls, pipe.select("l")) or {})
                    / (enablers[2] and func.map(ls, pipe.select("r")) or {})
                    / (enablers[1] and enablers[2] and func.map(ls, pipe.select("link")) or {})
                    / stairs(lc[c - 2], rc[c - 2], (lsc[sc - 4] + rsc[sc - 4]) * 0.5, tZ)
                    / stairs(lc[c + 2], rc[c + 2], (lsc[sc + 4] + rsc[sc + 4]) * 0.5, tZ)
                    / func.map2(il(func.range(lsc, sc - 3, sc + 3)), il(func.range(rsc, sc - 3, sc + 3)), function(lc, rc)
                        local b = ((lc.i + rc.i) * 0.5):withZ(1.4 + 0.53 - 3.5)
                        local t = ((lc.s + rc.s) * 0.5):withZ(1.4 + 0.53 - 3.5)
                        local vec = t - b
                        return station.newModel("person_lane.mdl", coor.scaleX(vec:length()), mRot(vec), coor.trans(b), tZ)
                    end)
                    /
                    {station.newModel("person_lane.mdl", coor.scaleX((newPtCon - ptCon):length()), mRotZ((newPtCon - ptCon)), mRot((newPtCon - ptCon)), coor.trans(ptCon))}
            end
        
        
        return terminals + newTerminals * pipe.flatten(),
            terminalsGroup
            + (
            (enablers[1] and enablers[2]) and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[1]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 15
                },
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[2]) * pipe.map(function(s) return {s - 1 + #terminals + #newTerminals[1], 0} end),
                    vehicleNodeOverride = #edges * 8 - 7
                }
            } or enablers[1] and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[1]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 7
                }
            } or enablers[2] and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[2]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 7
                }
            } or {}
            ),
            newPtCon
    end
end

local assembleSize = function(l, r, lc, rc, z)
    return {
        lb = lc.i:withZ(z),
        lt = lc.s:withZ(z),
        rb = rc.i:withZ(z),
        rt = rc.s:withZ(z)
    }
end

local generateModels = function(arcPacker, hPlatform)
    local il = pipe.interlace({"i", "s"})
    local tZ = coor.transZ(hPlatform - 1.4)
    return function(xOffsets, uOffsets)
        uOffsets = {uOffsets[1] - 0.5, uOffsets[2] + 0.5}
        local _, fzL, fsL = arcPacker()(xOffsets[1], uOffsets[1])
        local _, fzR, fsR = arcPacker()(xOffsets[2], uOffsets[2])
        local l, r = table.unpack(func.map2(xOffsets, uOffsets, arcPacker()))
        local lp, rp = table.unpack(func.map2(xOffsets, uOffsets, arcPacker(function(l) return l * 0.75 end)))
        local li, ri = table.unpack(func.map2(xOffsets, {uOffsets[1] + 0.8, uOffsets[2] - 0.8}, arcPacker()))
        local lpi, rpi = table.unpack(func.map2(xOffsets, {uOffsets[1] + 1, uOffsets[2] - 1}, arcPacker(function(l) return l * 0.75 end)))
        local newModels = pipe.new
            + pipe.mapn(func.seq(1, #l), l, r, li, ri)(function(i, l, r, li, ri)
                local lc, rc, lci, rci = table.unpack(retriveBiLatCoords(5)(equalizeArcs(l, r, li, ri)))
                local platformSurface = (pipe.new * pipe.rep(3)("platform_surface") / "platform_stair"
                    + pipe.new * pipe.rep(#lci - 6)("platform_surface") / "platform_extremity") * (i == 1 and pipe.rev() or pipe.noop())
                local platformEdge = pipe.new * pipe.rep(#lci - 2)("platform_edge") / "platform_corner" * (i == 1 and pipe.rev() or pipe.noop())
                local flipM = i == 1 and coor.I() or coor.flipY()
                return pipe.mapn(platformEdge, platformSurface, il(lc), il(lci), il(rci), il(rc))
                    (function(e, s, lc, lic, ric, rc)
                        local sizeL = assembleSize(l, li, lc, lic, hPlatform + 0.53)
                        local sizeR = assembleSize(ri, r, ric, rc, hPlatform + 0.53)
                        local sizeS = assembleSize(li, ri, lic, ric, hPlatform + 0.53)
                        return {
                            station.newModel(s .. "_br.mdl", tZ, flipM, fitModel(3.4, 5, hPlatform + 0.53, sizeS, i ~= 1, false)),
                            station.newModel(s .. "_tl.mdl", tZ, flipM, fitModel(3.4, 5, hPlatform + 0.53, sizeS, i == 1, true)),
                            station.newModel(e .. "_br.mdl", tZ, flipM, fitModel(0.8, 5, hPlatform + 0.53, sizeL, i ~= 1, false)),
                            station.newModel(e .. "_tl.mdl", tZ, flipM, fitModel(0.8, 5, hPlatform + 0.53, sizeL, i == 1, true)),
                            station.newModel(e .. "_bl.mdl", tZ, flipM, fitModel(0.8, 5, hPlatform + 0.53, sizeR, i ~= 1, true)),
                            station.newModel(e .. "_tr.mdl", tZ, flipM, fitModel(0.8, 5, hPlatform + 0.53, sizeR, i == 1, false))
                        }
                    end)
            end)
            + pipe.mapn(func.seq(1, #lp), lp, rp, lpi, rpi)(function(i, l, r, li, ri)
                local lc, rc, lci, rci = table.unpack(retriveBiLatCoords(10)(equalizeArcs(l, r, li, ri)))
                local roofSurface = pipe.new * pipe.rep(#lci - 2)("platform_roof_top") / "platform_roof_extremity" * (i == 1 and pipe.rev() or pipe.noop())
                local roofEdge = pipe.new * pipe.rep(#lci - 2)("platform_roof_edge") / "platform_roof_corner" * (i == 1 and pipe.rev() or pipe.noop())
                local flipM = i == 1 and coor.I() or coor.flipY()
                return pipe.new + pipe.mapn(roofEdge, roofSurface, il(lc), il(lci), il(rci), il(rc))
                    (function(e, s, lc, lic, ric, rc)
                        local sizeL = assembleSize(l, li, lc, lic, hPlatform)
                        local sizeR = assembleSize(ri, r, ric, rc, hPlatform)
                        local sizeS = assembleSize(li, ri, lic, ric, hPlatform)
                        local vecPo = ((sizeS.lb - sizeS.lt) + (sizeS.rb - sizeS.rt)) * 0.5
                        return {
                            station.newModel(s .. "_br.mdl", tZ, flipM, fitModel(3, 10, hPlatform, sizeS, i ~= 1, false)),
                            station.newModel(s .. "_tl.mdl", tZ, flipM, fitModel(3, 10, hPlatform, sizeS, i == 1, true)),
                            station.newModel(e .. "_br.mdl", tZ, flipM, fitModel(1, 10, hPlatform, sizeL, i ~= 1, false)),
                            station.newModel(e .. "_tl.mdl", tZ, flipM, fitModel(1, 10, hPlatform, sizeL, i == 1, true)),
                            station.newModel(e .. "_br.mdl", tZ, flipM, coor.flipX(), fitModel(1, 10, hPlatform, sizeR, i ~= 1, true)),
                            station.newModel(e .. "_tl.mdl", tZ, flipM, coor.flipX(), fitModel(1, 10, hPlatform, sizeR, i == 1, false)),
                            station.newModel("platform_roof_pole.mdl", tZ, flipM, coor.flipY(), coor.xXY(), mRot(vecPo), coor.trans((sizeS.lb + sizeS.lt + sizeS.rb + sizeS.rt) * 0.25), coor.transZ(-hPlatform))
                        }
                    end)
            end)
            + pipe.mapn(func.seq(1, #l), l, r, li, ri)(function(i, _, _, li, ri)
                local lci, rci = table.unpack(retriveBiLatCoords(20)(equalizeArcs(li, ri)))
                return pipe.new * pipe.mapn(func.seq(1, #lci - 1), il(lci), il(rci))
                    (function(j, lc, rc)
                        local lb = lc.i:withZ(0)
                        local lt = lc.s:withZ(0)
                        local rb = rc.i:withZ(0)
                        local rt = rc.s:withZ(0)
                        local vec = ((lb - lt) + (rb - rt)) * 0.5
                        return j % 2 == (i == 1 and 0 or 1) and {station.newModel("platform_chair.mdl", tZ, mRot(vec), coor.trans((lb + lt + rb + rt) * 0.25))} or {}
                    end)
            end)
        return newModels * pipe.flatten() * pipe.flatten()
    end
end


local generateTerrain = function(arcPacker)
    local il = pipe.interlace({"i", "s"})
    return function(xOffsets, uOffsets)
        uOffsets = {uOffsets[1] - 0.5, uOffsets[2] + 0.5}
        local l, r = table.unpack(func.map2(xOffsets, uOffsets, arcPacker(function(l) return l + 5 end)))
        return pipe.new
            * pipe.mapn(l, r)(function(l, r)
                local lc, rc = table.unpack(retriveBiLatCoords(5)(equalizeArcs(l, r)))
                local flipM = i == 1 and coor.I() or coor.flipY()
                return pipe.mapn(il(lc), il(rc))
                    (function(lc, rc)
                        local size = assembleSize(l, r, lc, rc, 0)
                        return pipe.new / size.lt / size.lb / size.rb / size.rt * pipe.map(coor.vec2Tuple) * ((size.lb - size.lt):cross(size.rb - size.lb).z > 0 and pipe.noop() or pipe.rev())
                    end)
            end)
            * pipe.flatten()
    end
end

local rBuild = function(totalTracks, baseX, arcPacker, hPlatform, wPlatform, ignoreFst, ignoreLst)
    local pW = wPlatform
    local tW = 5
    local generateEdges = generateEdges(arcPacker)
    local generateModels = generateModels(arcPacker, hPlatform)
    local generateTerminals = generateTerminals(arcPacker, hPlatform)
    local generateTerrain = generateTerrain(arcPacker)
    local tOffset = function(po) return {po[1] + 1, po[2] - 1} end
    local function build(nbTracks, baseX, incrX, edges, terminals, terminalsGroup, models, terrain, ptCon)
        if (nbTracks == 0) then
            return edges, terminals, terminalsGroup, models, terrain
        elseif (nbTracks == totalTracks and (not ignoreFst or totalTracks == 1)) then
            local edgeBase = baseX + 0.5 * tW + 0.5 * pW
            local edgeOffset = 0
            local platformBase = {edgeBase, edgeBase}
            local platformOffset = {-0.5 * tW - pW, -0.5 * tW}
            edges = generateEdges(edges, false, edgeBase)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true}, ptCon)
            return build(nbTracks - 1, edgeBase, tW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        elseif (nbTracks == 1 and ignoreLst) then
            local edgeBase = baseX + incrX + 0.5 * tW + 0.5 * pW
            local edgeOffset = 0
            local platformBase = {baseX, edgeBase}
            local platformOffset = {0.5 * tW, -0.5 * tW}
            local terminalOffset = {platformOffset[1] + 1, platformOffset[2] - 1}
            edges = generateEdges(edges, false, edgeBase)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true}, ptCon)
            return build(nbTracks - 1, baseX, 1.5 * tW + 0.5 * pW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        elseif (nbTracks == 1 and not ignoreLst) then
            local edgeBase = baseX
            local edgeOffset = incrX
            local platformBase = {baseX, baseX + incrX}
            local platformOffset = {incrX + 0.5 * tW, 0.5 * tW + pW}
            edges = generateEdges(edges, true, edgeBase, edgeOffset)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, false}, ptCon)
            return build(nbTracks - 1, baseX, pW + 0.5 * tW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        else
            local platformBase = {baseX, baseX + incrX + tW + pW}
            local platformOffset = {incrX + 0.5 * tW, -0.5 * tW}
            edges = generateEdges(edges, true, baseX, incrX)
            edges = generateEdges(edges, false, baseX + incrX + tW + pW)
            terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, true}, ptCon)
            return build(nbTracks - 2, baseX + incrX + tW + pW, tW,
                edges,
                terminals,
                terminalsGroup,
                models + generateModels(platformBase, platformOffset),
                terrain + generateTerrain(platformBase, platformOffset),
                ptCon)
        end
    end
    return build(totalTracks, baseX, 0, pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, coor.xyz(0, 0, 0))
end


local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = wPlatformList[params.wPlatform + 1]
        
        local nSeg = platformSegments[params.length + 1]
        local length = nSeg * station.segmentLength
        
        local nbTracks = trackNumberList[params.nbTracks + 1]
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local slope = slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local edge, terminals, terminalsGroup, models, terrain = rBuild(nbTracks, 0, arcPacker(radius, incr, length, slope), hPlatform, wPlatform,
            ({true, false, true, false})[params.trackLayout + 1],
            (nbTracks % 2 == 0 and {false, false, true, true} or {true, true, false, false})[params.trackLayout + 1]
        )
        return
            pipe.new
            * {
                edgeLists = {pipe.new * {edge * (station.mergeEdges)} * station.prepareEdges * trackBuilder.normal()},
                models = terminals + models,
                terminalGroups = terminalsGroup,
                terrainAlignmentLists = {
                    {
                        type = "EQUAL",
                        faces = terrain,
                        slopeLow = 0.75,
                        slopeHigh = 2.5
                    }
                }
            }
    end
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 27218,
        params = params(),
        updateFn = updateFn()
    }
end
