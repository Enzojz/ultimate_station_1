local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local line = require "ustation/coorline"
local arc = require "ustation/coorarc"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local pipe = require "ustation/pipe"
local ust = require "ustation"

local dump = require "datadumper"

local abs = math.abs
local ceil = math.ceil
local floor = math.floor
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {ust.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}

local platformSegments = {2, 4, 8, 12, 16, 20, 24}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 12}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "length",
            name = _("Platform length") .. "(m)",
            values = func.map(platformSegments, function(l) return _(tostring(l * station.segmentLength)) end),
            defaultIndex = 2
        },
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "trackLayout",
            name = _("Track Layout"),
            values = func.map({1, 2, 3, 4}, tostring),
            defaultIndex = 0
        },
        {
            key = "sign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    param.trackType = param.trackType or 0
    param.catenary = param.catenary or 0
    
    func.forEach(
        func.filter(params({}), function(p) return p.key ~= "tramTrack" end),
        function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)

end

local arcPacker = function(radius, incr, length)
    local baseCenter = coor.xy(radius, 0)
    local initRad = radius > 0 and pi or 0
    return function(x, dr)
        dr = dr or 0
        local ar = arc.byOR(baseCenter + coor.xy(radius > 0 and x or -x, 0), abs(radius + (radius > 0 and -dr or dr)))
        local rad = (radius > 0 and 1 or -1) * length / ar.r * 0.25
        return pipe.new
            / ar:withLimits({
                inf = initRad - rad * 2,
                sup = initRad - rad
            })
            / ar:withLimits({
                inf = initRad - rad,
                sup = initRad
            })
            / ar:withLimits({
                inf = initRad,
                sup = initRad + rad
            })
            / ar:withLimits({
                inf = initRad + rad,
                sup = initRad + rad * 2
            })
    end
end

local generateEdges = function(arcPacker)
    return function(edges, xOffset, xtOffset)
        return edges /
            {
                edge = arcPacker(xOffset, xtOffset) * pipe.map(ust.generateArc),
                snap = pipe.new * {}
            }
    end
end

local function mPlace(guideline, rad1, rad2)
    local rad = rad2 and (rad1 + rad2) * 0.5 or rad1
    local z = 0
    local s = 0
    local pt = guideline:pt(rad)
    return coor.shearZoY(s) * coor.transZ(z) * coor.rotZ(rad) * coor.trans(func.with(pt, {z = 0}))
end

local mRot = function(vec)
    local nv = vec:normalized()
    local sx = nv.y
    local cx = nv.x
    return coor.I() * {
        cx, sx, 0, 0,
        -sx, cx, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    }
end

local mShear = function(vec)
    local nv = vec:normalized()
    return coor.I() * {
        1, 0, 0, 0,
        nv.x / nv.y, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    }
end

local retriveBiLatCoords = function(l, r, length)
    l = l:withLimits(
        {
            inf = ust.normalizeRad(l:rad((l:pt(l.inf) + r:pt(r.inf)) * 0.5)),
            sup = ust.normalizeRad(l:rad((l:pt(l.sup) + r:pt(r.sup)) * 0.5))
        }
    )
    r = r:withLimits(
        {
            inf = ust.normalizeRad(r:rad((l:pt(l.inf) + r:pt(r.inf)) * 0.5)),
            sup = ust.normalizeRad(r:rad((l:pt(l.sup) + r:pt(r.sup)) * 0.5))
        }
    )
    local nSeg = (function(x) return (x < 1 or (x % 1 > 0.5)) and ceil(x) or floor(x) end)(l:length() / length)
    local lscale = l:length() / (nSeg * length)
    local rscale = r:length() / (nSeg * length)
    local lcoords = abs(lscale) < 1e-5 and {} or func.seqMap({0, nSeg}, function(n) return l.inf + n * ((l.sup - l.inf) / nSeg) end)
    local rcoords = abs(rscale) < 1e-5 and {} or func.seqMap({0, nSeg}, function(n) return r.inf + n * ((r.sup - r.inf) / nSeg) end)
    return lscale, rscale, lcoords, rcoords
end

local generateTerminals = function(arcPacker)
    return function(edges, terminals, terminalsGroup, xOffsets, uOffsets, enablers)
        local l, r = table.unpack(func.map2(xOffsets, uOffsets, arcPacker))
        local newTerminals =
            pipe.new * func.map2(l, r, function(l, r)
                local lscale, rscale, lcoords, rcoords = retriveBiLatCoords(l, r, 10)
                return pipe.new
                    * func.map2(func.interlace(lcoords, {"i", "s"}), func.interlace(rcoords, {"i", "s"}), function(lc, rc)
                        local lb = l:pt(lc.i):withZ(1.2)
                        local lt = l:pt(lc.s):withZ(1.2)
                        local rb = r:pt(rc.i):withZ(1.2)
                        local rt = r:pt(rc.s):withZ(1.2)
                        local vecl = (lt - lb)
                        local vecr = (rt - rb)
                        local vectl = (lt - rt)
                        return {
                            l = station.newModel("terminal_lane.mdl", coor.scaleX(vecl:length()), mRot(vecl), coor.trans(lb)),
                            r = station.newModel("terminal_lane.mdl", coor.scaleX(vecr:length()), mRot(vecr), coor.trans(rb)), 
                            link = station.newModel("person_lane.mdl", coor.scaleX(vectl:length()), mRot(vectl), coor.trans(rt)),
                        }
                    end)
                    * function(ls) return {
                        l = ls * pipe.map(pipe.select("l")),
                        r = ls * pipe.map(pipe.select("r")),
                        link = ls * pipe.map(pipe.select("link"))
                    }
                    end
            end)
            * function(ls)
                return pipe.new
                    / (enablers[1] and func.mapFlatten(ls, pipe.select("l")) or {})
                    / (enablers[2] and func.mapFlatten(ls, pipe.select("r")) or {})
                    / (enablers[1] and enablers[2] and func.mapFlatten(ls, pipe.select("link")) or {})
            end
        return terminals + newTerminals * pipe.flatten(),
            terminalsGroup
            + (
            (enablers[1] and enablers[2]) and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[1]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 12
                },
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[2]) * pipe.map(function(s) return {s - 1 + #terminals + #newTerminals[1], 0} end),
                    vehicleNodeOverride = #edges * 8 - 4
                }
            } or enablers[1] and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[1]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 4
                }
            } or enablers[2] and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[2]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 4
                }
            } or {}
    )
    end
end

local generateModels = function(arcPacker)
    return function(models, xOffsets, uOffsets)
        local l, r = table.unpack(func.map2(xOffsets, uOffsets, arcPacker))
        return models
            + pipe.new * func.map2(l, r, function(l, r)
                local lscale, rscale, lcoords, rcoords = retriveBiLatCoords(l, r, 5)
                return
                    pipe.new * func.interlace(lcoords)
                    * pipe.map(function(rad) return station.newModel("platform_repeat.mdl", coor.flipX(), coor.scaleY(lscale), mPlace(l, rad[1], rad[2])) end)
                    + pipe.new * func.interlace(rcoords)
                    * pipe.map(function(rad) return station.newModel("platform_repeat.mdl", coor.scaleY(rscale), mPlace(r, rad[1], rad[2])) end)
                    + pipe.new * func.map2(func.interlace(lcoords, {"i", "s"}), func.interlace(rcoords, {"i", "s"}), function(lc, rc)
                        local lb = l:pt(lc.i):withZ(0)
                        local lt = l:pt(lc.s):withZ(0)
                        local rb = r:pt(rc.i):withZ(0)
                        local rt = r:pt(rc.s):withZ(0)
                        local vecb = rb - lb
                        local vect = rt - lt
                        local vecl = (lt - lb) .. mRot(vect .. coor.flipX())
                        local vecr = (rt - rb) .. mRot(vecb .. coor.flipX())
                        return {
                            station.newModel("platform_surface_br.mdl", coor.scale(coor.xyz(vecb:length() / 5, -vecr.y / 5, 1)), mShear(vecr), mRot(vecb), coor.trans(rb)),
                            station.newModel("platform_surface_tl.mdl", coor.scale(coor.xyz(vect:length() / 5, -vecl.y / 5, 1)), mShear(vecl), mRot(vect), coor.trans(lt))
                        }
                    end) * pipe.flatten()
            end)
            * pipe.flatten()
    end
end

local rBuild = function(totalTracks, baseX, arcPacker, ignoreFst, ignoreLst)
    local pW = station.platformWidth
    local tW = station.trackWidth
    local generateEdges = generateEdges(arcPacker)
    local generateModels = generateModels(arcPacker)
    local generateTerminals = generateTerminals(arcPacker)
    local tOffset = function(po) return {po[1] + 1, po[2] - 1} end
    local function build(nbTracks, baseX, incrX, edges, terminals, terminalsGroup, models)
        if (nbTracks == 0) then
            return edges, terminals, terminalsGroup, models
        elseif (nbTracks == totalTracks and not ignoreFst) then
            local edgeBase = baseX + 0.5 * tW + 0.5 * pW
            local edgeOffset = 0
            local platformBase = {edgeBase, edgeBase}
            local platformOffset = {-0.5 * tW - pW, -0.5 * tW}
            edges = generateEdges(edges, edgeBase)
            models = generateModels(models, platformBase, platformOffset)
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true})
            return build(nbTracks - 1, edgeBase, tW, edges, terminals, terminalsGroup, models)
        elseif (nbTracks == 1 and ignoreLst) then
            local edgeBase = baseX + incrX + 0.5 * tW + 0.5 * pW
            local edgeOffset = 0
            local platformBase = {baseX, edgeBase}
            local platformOffset = {0.5 * tW, -0.5 * tW}
            local terminalOffset = {platformOffset[1] + 1, platformOffset[2] - 1}
            edges = generateEdges(edges, edgeBase)
            models = generateModels(models, platformBase, platformOffset)
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true})
            return build(nbTracks - 1, baseX, 1.5 * tW + 0.5 * pW, edges, terminals, terminalsGroup, models)
        elseif (nbTracks == 1 and not ignoreLst) then
            local edgeBase = baseX
            local edgeOffset = incrX
            local platformBase = {baseX, baseX + incrX}
            local platformOffset = {incrX + 0.5 * tW, 0.5 * tW + pW}
            edges = generateEdges(edges, edgeBase, edgeOffset)
            models = generateModels(models, platformBase, platformOffset)
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, false})
            return build(nbTracks - 1, baseX, pW + 0.5 * tW, edges, terminals, terminalsGroup, models)
        else
            local platformBase = {baseX, baseX + incrX + tW + pW}
            local platformOffset = {incrX + 0.5 * tW, -0.5 * tW}
            edges = generateEdges(edges, baseX, incrX)
            edges = generateEdges(edges, baseX + incrX + tW + pW)
            models = generateModels(models, platformBase, platformOffset)
            terminals, terminalsGroup = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, true})
            return build(nbTracks - 2, baseX + incrX + tW + pW, tW, edges, terminals, terminalsGroup, models)
        end
    end
    return build(totalTracks, baseX, 0, pipe.new, pipe.new, pipe.new, pipe.new)
end


local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        
        local nSeg = platformSegments[params.length + 1]
        local length = nSeg * station.segmentLength
        
        local nbTracks = trackNumberList[params.nbTracks + 1]
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        
        local edge, terminals, terminalsGroup, models = rBuild(nbTracks, 0, arcPacker(radius, incr, length),
            ({true, false, true, false})[params.trackLayout + 1],
            (nbTracks % 2 == 0 and {false, false, true, true} or {true, true, false, false})[params.trackLayout + 1]
        )
        dump.dump(terminalsGroup)
        return
            pipe.new
            * {
                edgeLists = {pipe.new * {edge * (station.mergeEdges)} * station.prepareEdges * trackBuilder.normal()},
                models = terminals + models,
                terminalGroups = terminalsGroup
            -- terrainAlignmentLists = {}
            }
    end
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 27218,
        params = params(),
        updateFn = updateFn()
    }
end
