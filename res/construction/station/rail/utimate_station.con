local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local quat = require "ustation/quaternion"
local pipe = require "ustation/pipe"
local ust = require "ustation"

local dump = require "datadumper"

local abs = math.abs
local ceil = math.ceil
local floor = math.floor
local pi = math.pi
local atan = math.atan
local cos = math.cos
local sin = math.sin

local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}
local rList = {ust.infi * 0.001, 5, 3.5, 2, 1, 4 / 5, 2 / 3, 3 / 5, 1 / 2, 1 / 3, 1 / 4, 1 / 5, 1 / 6, 1 / 8, 1 / 10, 1 / 20}
local hPlatformList = {200, 280, 380, 550, 680, 760, 915, 960, 1100, 1219, 1250, 1380}
local wPlatformList = {4, 5, 6, 7, 8}
local roofLengthList = {100, 95, 80, 75, 50, 25, 0}

local buildingList = {
    "main_building_size1.mdl",
    "main_building_size2.mdl",
    "main_building_size4.mdl",
    "main_building_size5.mdl",
}

local fencesLengthList = {
    2, 2.5, 2
}

local bZ = 0.8
local buildingParamsList = {
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.5, 0),
            coor.xyz(5, -1.5, 0)
        },
        pass = {
            coor.xyz(1, 0, -bZ)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 9
    },
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.5, 0),
            coor.xyz(5, -1.5, 0)
        },
        pass = {
            coor.xyz(0, 0, 0)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 15.5
    },
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.8, 0),
            coor.xyz(5, -1.8, 0)
        },
        pass = {
            coor.xyz(0, 0, 0)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 22.5
    },
    {
        entry = {
            coor.xyz(-8, 1.5, -bZ),
            coor.xyz(-8, -1.5, -bZ)
        },
        platform = {
            coor.xyz(5, 1.8, 0),
            coor.xyz(5, -1.8, 0)
        },
        pass = {
            coor.xyz(0, 0, 0)
        },
        street = coor.xyz(-12 + 2, 0, 0),
        halfWidth = 30
    }
}

local trackLengths = {60, 80, 100, 160, 200, 240, 320, 400, 480, 500, 550, 850, 1050, 1750}
local trackNumberList = {1, 2, 3, 4, 5, 6, 7, 8, 10, 12}
local slopeList = {0, 2.5, 5, 7.5, 10, 12.5, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return {
        {
            key = "nbTracks",
            name = _("Number of tracks"),
            values = func.map(trackNumberList, tostring),
        },
        {
            key = "length",
            name = _("Platform length") .. "(m)",
            values = func.map(trackLengths, tostring),
            defaultIndex = 3
        },
        paramsutil.makeTrackTypeParam(),
        paramsutil.makeTrackCatenaryParam(),
        {
            key = "trackLayout",
            name = _("Track Layout"),
            values = func.map({1, 2, 3, 4}, tostring),
            defaultIndex = 0
        },
        {
            key = "sign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "radius",
            name = _("Radius") .. "(m)",
            values = pipe.from("∞") + func.map(func.range(rList, 2, #rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
            defaultIndex = 0
        },
        {
            key = "hPlatform",
            name = sp .. "\n" .. _("Platform") .. "\n" .. _("Height") .. "(mm)",
            values = func.map(hPlatformList, tostring),
            defaultIndex = 3
        },
        {
            key = "wPlatform",
            name = _("Width") .. "(m)",
            values = func.map(wPlatformList, tostring),
            defaultIndex = 1
        },
        {
            key = "roofLength",
            name = _("Roof length") .. "(%)",
            values = func.map(roofLengthList, tostring),
            defaultIndex = 3
        },
        {
            key = "slopeSign",
            name = sp,
            values = {"+", "-"},
            defaultIndex = 0
        },
        {
            key = "slope",
            name = _("Slope") .. "(‰)",
            values = func.map(slopeList, tostring),
            defaultIndex = 0
        },
        {
            key = "entrySize",
            name = _("Entry"),
            values = {"S", "M", "L", "XL"},
            defaultIndex = 1
        },
        {
            key = "fencesPos",
            name = _("Fences"),
            values = {"None", "A", "B", "A+B"},
            defaultIndex = 0
        },
        {
            key = "fencesStyle",
            name = _("Fences Style"),
            values = {"A", "B", "C"},
            defaultIndex = 0
        },
        {
            key = "fencesColor",
            name = _("Fences Color"),
            values = {"White", "Green", "Yellow"},
            defaultIndex = 0
        }
    }
end

local function defaultParams(param)
    local function limiter(d, u)
        return function(v) return v and v < u and v or d end
    end
    param.trackType = param.trackType or 0
    param.catenary = param.catenary or 0
    
    func.forEach(
        func.filter(params({}), function(p) return p.key ~= "tramTrack" end),
        function(i)param[i.key] = limiter(i.defaultIndex or 0, #i.values)(param[i.key]) end)

end


local function trackGrouping(result)
    return function(ar1, ar2, ar3, ...)
        if (ar1 == nil) then return result end
        
        if (ar1 and ar2 and ar3) then
            if #ar1 == 1 and #ar2 == 2 and #ar3 == 1 then
                return trackGrouping(result / {ar1, ar2, ar3})(...)
            end
        end
        
        if (ar1 and ar2) then
            if (#ar1 + #ar2 == 3) then
                return trackGrouping(result / {ar1, ar2})(ar3, ...)
            end
        end
        
        return trackGrouping(result / {ar1})(ar2, ar3, ...)
    end
end

local rBuild = function(totalTracks, baseX, arcPacker, config, ignoreFst, ignoreLst)
    local pW = config.wPlatform
    local tW = 5
    local bandWidth = 1
    local factorW = 0.5
    local fitModel = slope == 0 and ust.fitModel2D or ust.fitModel
    local generateEdges = ust.generateEdges(arcPacker()())
    local generateModels = ust.generateModels(arcPacker, fitModel, config)
    local generateFences = ust.generateFences(arcPacker, fitModel, config)
    local generateTerminals = ust.generateTerminals(arcPacker, config)
    local generateTerrain = ust.generateTerrain(arcPacker())
    local tOffset = function(po) return {po[1] + 1, po[2] - 1} end
    local refZ = config.hPlatform + 0.53
    
    local buildEntryPath = function()
        local xOffset = -6.5
        local mX = coor.trans(coor.xyz(xOffset, 0, refZ))
        local mRo = coor.rotX(atan(-config.slope))
        local m = mX * mRo
        return
            pipe.new * func.map(config.buildingParams.platform, function(p) return ust.unitLane(p .. m, coor.xyz(baseX + 0.5 * pW - 1, 0, refZ)) end)
            + func.map(config.buildingParams.entry, function(p) return ust.unitLane(p .. m, coor.xyz(-10 + xOffset, p.y > 0 and 4.5 or -4.5, 0)) end)
            + func.map(config.buildingParams.pass, function(p) return ust.unitLane(p .. m, coor.xyz(-1, 0, refZ - 3.5)) end)
    end
    
    local buildAccessRoad = function()
        local pO = coor.xyz(-6.5, 0, 0)
        return {
            edge = pipe.new / {config.buildingParams.street + pO, config.buildingParams.street + pO + coor.xyz(-20, 0, 0), coor.xyz(-1, 0, 0), coor.xyz(-1, 0, 0)},
            snap = pipe.new / {false, true}
        }
    end
    
    local buildFace = function()
        local z = refZ - 0.8
        local mRot = coor.rotX(atan(-config.slope))
        local mX = coor.transX(-6.5)
        local xMin = config.buildingParams.street.x
        local xMax = baseX - 0.5 * pW
        local yMin = -config.buildingParams.halfWidth
        local yMax = config.buildingParams.halfWidth
        return pipe.new
            / {
                coor.xyz(config.buildingParams.entry[1].x, yMin, z) .. mX * mRot,
                coor.xyz(xMax, yMin, z) .. mRot,
                coor.xyz(xMax, yMax, z) .. mRot,
                coor.xyz(config.buildingParams.entry[1].x, yMax, z) .. mX * mRot
            }
            / {
                coor.xyz(config.buildingParams.street.x, yMin, 0) .. mX,
                coor.xyz(config.buildingParams.entry[1].x, yMin, z) .. mX * mRot,
                coor.xyz(config.buildingParams.entry[1].x, yMax, z) .. mX * mRot,
                coor.xyz(config.buildingParams.street.x, yMax, 0) .. mX
            }
            * pipe.map(pipe.map(coor.vec2Tuple))
    end
    
    local function preBuild(nbTracks, result)
        local p = false
        local t = true
        if (nbTracks == 0) then
            return result
        elseif (nbTracks == totalTracks and (not ignoreFst or totalTracks == 1)) then
            return preBuild(nbTracks - 1, result / p / t)
        elseif (nbTracks == 1 and ignoreLst) then
            return preBuild(nbTracks - 1, result / p / t)
        elseif (nbTracks == 1 and not ignoreLst) then
            return preBuild(nbTracks - 1, result / t / p)
        else
            return preBuild(nbTracks - 2, result / t / p / t)
        end
    end
    
    local ptList = preBuild(totalTracks, pipe.new)
    local ptListI = ptList * pipe.zip(func.seq(1, #ptList), {"t", "i"})
    local middlePos = #ptList % 2 == 0 and (#ptList * 0.5) or ((#ptList + 1) * 0.5)
    
    
    local leftGroup = ptListI * pipe.filter(function(p) return p.i < middlePos end) * pipe.rev()
    local middleGroup = ptListI * pipe.filter(function(p) return p.i == middlePos end)
    local rightGroup = ptListI * pipe.filter(function(p) return p.i > middlePos end)
    
    local refArc = function(x, u)
        return {x = x, u = u}
    end
    
    local function generateArcs(init, initDr, initX)
        local function arcGen(result, dr, x, isRight)
            local f = isRight and 1 or -1
            return function(t, ...)
                if t == nil then
                    if isRight then
                        return result * pipe.sort(function(l, r) return l.i < r.i end) * pipe.map(pipe.select("a"))
                    else
                        return arcGen(result, initDr, initX, true)(table.unpack(rightGroup))
                    end
                else
                    if t.t then
                        return arcGen(result / {i = t.i, a = {refArc(dr + f * tW, x)}}, dr + f * tW, x, isRight)(...)
                    else
                        return arcGen(result / {i = t.i, a = {refArc(dr + f * 0.5 * tW, x), refArc(dr + f * 0.5 * tW + f * pW, x)}}, dr + f * pW - f * 0.5 * tW, x, isRight)(...)
                    end
                end
            end
        end
        return arcGen(init, initDr, initX)(table.unpack(leftGroup))
    end
    
    local allArcs = table.unpack(middleGroup).t and
        generateArcs(pipe.new / {i = middlePos, a = {refArc(0, 0)}}, 0, 0) or
        generateArcs(pipe.new / {i = middlePos, a = {refArc(-0.5 * pW, 0), refArc(0.5 * pW, 0)}}, -0.5 * pW + 0.5 * tW, 0)
    
    local function build(edges, terminals, terminalsGroup, models, terrain, ptCon)
        return function(gr, ...)
            if (gr == nil) then
                return edges, buildAccessRoad(), terminals, terminalsGroup,
                    models, -- + buildEntryPath() + {station.newModel(config.entryModel, coor.rotZ(-pi * 0.5), coor.transX(-6.5), coor.transZ(config.hPlatform - 0.25), coor.rotX(atan(-config.slope)))},
                    terrain -- + buildFace()
            elseif (#gr == 3) then
                local platformBase = {gr[2][1].x, gr[2][2].x}
                local platformOffset = {gr[2][1].u, gr[2][2].u}
                edges = generateEdges(edges, true, gr[1][1].x, gr[1][1].u)
                edges = generateEdges(edges, false, gr[3][1].x, gr[3][1].u)
                terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, true}, ptCon)
                return build(
                    edges,
                    terminals,
                    terminalsGroup,
                    models + generateModels(platformBase, platformOffset)
                    + (config.leftFences and nbTracks == totalTracks and generateFences({baseX, baseX + incrX + tW + pW}, {-2, 2}, true, true) or {})
                    + (config.rightFences and nbTracks == 2 and generateFences({baseX, baseX + incrX + tW + pW}, {-2, 2}, false, true) or {}),
                    terrain + generateTerrain(platformBase, platformOffset),
                    ptCon)(...)
            elseif (#gr == 2 and #gr[1] == 1 and #gr[2] == 2) then
                local platformBase = {gr[2][1].x, gr[2][2].x}
                local platformOffset = {gr[2][1].u, gr[2][2].u}
                edges = generateEdges(edges, true, gr[1][1].x, gr[1][1].u)
                terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {true, false}, ptCon)
                return build(
                    edges,
                    terminals,
                    terminalsGroup,
                    models
                    + generateModels(platformBase, platformOffset)
                    + (config.rightFences and generateFences(platformBase, platformOffset, false) or {}),
                    terrain + generateTerrain(platformBase, platformOffset),
                    ptCon)(...)
            elseif (#gr == 2 and #gr[1] == 2 and #gr[2] == 1) then
                local platformBase = {gr[1][1].x, gr[1][2].x}
                local platformOffset = {gr[1][1].u, gr[1][2].u}
                edges = generateEdges(edges, false, gr[2][1].x, gr[2][1].u)
                terminals, terminalsGroup, ptCon = generateTerminals(edges, terminals, terminalsGroup, platformBase, tOffset(platformOffset), {false, true}, ptCon)
                return build(edges,
                    terminals,
                    terminalsGroup,
                    models
                    + generateModels(platformBase, platformOffset)
                    + (config.rightFences and generateFences({edgeBase, edgeBase}, {-2, 2}, false, true) or {}),
                    terrain + generateTerrain(platformBase, platformOffset),
                    ptCon)(...)
            else
                edges = generateEdges(edges, false, gr[1][1].x, gr[1][1].u)
                return build(edges,
                    terminals,
                    terminalsGroup,
                    models,
                    terrain,
                    ptCon)(...)
            end
        end
    end
    
    local gr = trackGrouping(pipe.new)(table.unpack(allArcs))
    return build(pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, pipe.new / coor.xyz(-1, 0, config.hPlatform - 3.5 + 0.53))(table.unpack(gr))
end

local updateFn = function()
    return function(params)
        defaultParams(params)
        
        local trackType = ({"standard.lua", "high_speed.lua"})[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = wPlatformList[params.wPlatform + 1]
        local roofLength = roofLengthList[params.roofLength + 1] * 0.01
        local mainBuilding = buildingList[params.entrySize + 1]
        local fencesLength = fencesLengthList[params.fencesStyle + 1]
        local fencesModel = {
            "fences/" .. tostring(params.fencesColor + 1) .. "/platform_fences_" .. tostring(params.fencesStyle + 1) .. ".mdl",
            "fences/" .. tostring(params.fencesColor + 1) .. "/platform_fences_pole_" .. tostring(params.fencesStyle + 1) .. ".mdl",
        }
        
        local length = trackLengths[params.length + 1]
        
        local nbTracks = trackNumberList[params.nbTracks + 1]
        local radius = (rList[params.radius + 1] * 1000) * (params.sign == 0 and 1 or -1)
        local slope = slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local edge, streetEdge, terminals, terminalsGroup, models, terrain =
            rBuild(nbTracks, 0,
                ust.arcPacker(radius, incr, length, slope),
                {
                    hPlatform = hPlatform,
                    wPlatform = wPlatform,
                    roofLength = roofLength,
                    buildingParams = buildingParamsList[params.entrySize + 1],
                    slope = slope,
                    fencesModel = fencesModel,
                    fencesLength = fencesLength,
                    entryModel = mainBuilding,
                    leftFences = params.fencesPos == 1 or params.fencesPos == 3,
                    rightFences = params.fencesPos == 2 or params.fencesPos == 3,
                },
                ({true, false, true, false})[params.trackLayout + 1],
                (nbTracks % 2 == 0 and {false, false, true, true} or {true, true, false, false})[params.trackLayout + 1]
        )
        return
            pipe.new
            * {
                edgeLists = pipe.new
                / (pipe.new * {edge * station.mergeEdges} * station.prepareEdges * trackBuilder.normal())
                / (pipe.new * {pipe.new * streetEdge} * station.prepareEdges * pipe.with(
                    {
                        type = "STREET",
                        params =
                        {
                            type = "station_new_small.lua",
                            tramTrackType = "NO"
                        }
                    }
                )),
                models = terminals + models,
                terminalGroups = terminalsGroup,
                terrainAlignmentLists = {
                    {
                        type = "EQUAL",
                        faces = terrain,
                        slopeLow = 0.75,
                        slopeHigh = 2.5
                    }
                },
                groundFaces = terrain * pipe.map(function(f) return {
                    {face = f, modes = {{type = "FILL", key = "industry_gravel_small_01"}}},
                    {face = f, modes = {{type = "STROKE_OUTER", key = "building_paving"}}}
                } end) * pipe.flatten()
            }
    end
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station"),
            description = _("One or many tracks with fix radious and signaling spacing.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 27218,
        params = params(),
        updateFn = updateFn()
    }
end
