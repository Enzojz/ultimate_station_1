local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local line = require "ustation/coorline"
local arc = require "ustation/coorarc"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local pipe = require "ustation/pipe"
local ust = require "ustation"
local uste = require "ustation_entries"
local ustm = require "ustation_menu"
local ma = math

local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)

local prefixM = "ust/1990/"
local buildingList, buildingParamsList = require("ustation_building")(prefixM)
local models = ust.models(prefixM)

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return pipe.new + ustm.trackType +
        {
            {
                key = "nbTracksA",
                name = sp .. "\n" .. _("Number of tracks") .. "\n\n" .. "A",
                values = func.map(ustm.trackNumberList, tostring),
                defaultIndex = 1
            },
            {
                key = "nbTracksB",
                name = "B",
                values = func.map(ustm.trackNumberList, tostring),
                defaultIndex = 1
            },
            {
                key = "nbTransitTracksA",
                name = sp .. "\n" .. _("Transit Tracks") .. "\n\n" .. "A",
                values = func.map({0, 1, 2, 3, 4}, tostring),
                defaultIndex = 0
            },
            {
                key = "posTransitTracksA",
                name = _("Position"),
                values = {_("Centre"), _("Outter")},
                defaultIndex = 0
            },
            {
                key = "nbTransitTracksB",
                name = "\n" .. "B",
                values = func.map({0, 1, 2, 3, 4}, tostring),
                defaultIndex = 0
            },
            {
                key = "posTransitTracksB",
                name = _("Position"),
                values = {_("Centre"), _("Outter")},
                defaultIndex = 0
            },
            {
                key = "radiusA",
                name = sp .. "\n" .. _("Radius") .. " " .. "(m)" .. "\n\n" .. "A",
                values = pipe.from("∞") +
                func.map(
                    func.range(ustm.rList, 2, #ustm.rList),
                    function(r)
                        return tostring(math.floor(r * 1000 + 0.5))
                    end
                ),
                defaultIndex = 0
            },
            {
                key = "radiusB",
                name = "B",
                values = pipe.from("∞") +
                func.map(
                    func.range(ustm.rList, 2, #ustm.rList),
                    function(r)
                        return tostring(math.floor(r * 1000 + 0.5))
                    end
                ),
                defaultIndex = 0
            },
            {
                key = "curveLayout",
                name = _("Polarity"),
                values = {"--", "-+", "++"},
                defaultIndex = 1
            },
            {
                key = "lengthA",
                name = sp .. "\n" .. _("Platform") .. "\n\n" .. _("Length") .. " " .. "(m)" .. "\n\n" .. "A",
                values = func.map(ustm.trackLengths, tostring),
                defaultIndex = 5
            },
            {
                key = "lengthB",
                name = "B",
                values = func.map(ustm.trackLengths, tostring),
                defaultIndex = 5
            }
        } +
        ustm.platform +
        {
            {
                key = "lengthMiddlePlatform",
                name = _("Central Platform Length") .. "(%)",
                values = func.map(ustm.middlePlatformLength, tostring),
                defaultIndex = 3
            }
        } +
        ustm.exclu("varRefType", "varRefPos")(ustm.var) +
        ustm.slope +
        ustm.entry +
        ustm.fence +
        ustm.alt
end
local il = pipe.interlace({"s", "i"})


local arcPacker = function(length, slope, rot, con)
    return function(radius, o, lengthVar, dislodge)
        local lengthVar = lengthVar and (1 - lengthVar) or 0
        local dislodge = dislodge and (dislodge * length / radius) or 0
        return function(z)
            local z = z or 0
            return function(lengthOverride)
                local l = lengthOverride and lengthOverride(length) or length
                return function(xDr)
                    local dr = xDr or 0
                    local ar = arc.byOR(o + coor.xyz(0, 0, z), abs(radius - dr))
                    local dRad = (radius > 0 and 1 or -1) * (l - length * lengthVar) / ar.r * 0.5
                    local initRad = (radius > 0 and pi or 0) + rot + con
                    return pipe.new
                        / ar:withLimits({
                            sup = initRad - dislodge - dRad,
                            inf = initRad - dislodge,
                            slope = -slope
                        }
                        )
                        / ar:withLimits({
                            inf = initRad - dislodge,
                            sup = initRad - dislodge + dRad,
                            slope = slope
                        }
                )
                end
            end
        end
    end
end

local function retriveRef(config, allArcs)
    if (not config.buildingParams) then
        return false
    end
    
    local arcsL, arcsR
    for i = 1, #allArcs - 1 do
        if #allArcs[i] > 1 and #allArcs[i + 1] > 1 then
            arcsL, arcsR = allArcs[i], allArcs[i + 1]
        end
    end
    
    if (arcsL and arcsR) then
        local ptL = arcsL.surface.rc[arcsL.platform.common + 1]
        local ptR = arcsR.surface.lc[arcsL.platform.common + 1]
        
        if (ptL - ptR):length() > (config.buildingParams.halfWidth) * 2 then
            return function()
                local refVec = (ptL - ptR):normalized() .. coor.rotZ(-0.5 * pi)
                local refPt = ptL:avg(ptR) + refVec
                return refPt, ust.mRot(refVec), arcsL.lane.rc[arcsL.lane.common - 1]:avg(
                    arcsR.lane.lc[arcsL.lane.common - 1],
                    arcsR.lane.lc[arcsL.lane.common],
                    arcsL.lane.rc[arcsL.lane.common]
                ), arcsL.surface.rc[arcsL.platform.common - 1]:avg(arcsR.surface.lc[arcsL.platform.common - 1])
            end
        end
    end
    
    return false
end


local buildUndergroundEntry = function(config, entryConfig)
    local allArcs = entryConfig.allArcs
    
    local arcCoords = pipe.new 
        * {ust.trackGrouping(pipe.new, table.unpack(allArcs))}
        * pipe.map(pipe.filter(function(a) return #a > 1 end))
        * pipe.map(function(g)
            if (#g == 1) then return g else
                local arcL, arcR = table.unpack(g)
                local coords = {
                    l = {
                        lc = arcL.platform.lc,
                        rc = arcR.platform.rc * pipe.range(1, arcL.platform.common) + arcL.platform.rc * pipe.range(arcL.platform.common + 1, #arcL.platform.rc),
                    },
                    r = {
                        lc = arcL.platform.lc * pipe.range(1, arcR.platform.common) + arcR.platform.lc * pipe.range(arcR.platform.common + 1, #arcR.platform.lc),
                        rc = arcR.platform.rc
                    }
                }
                local mc = function(lc, rc) return func.map2(lc, rc, function(l, r) return l:avg(r) end) end
                
                return {
                    {
                        platform = func.with(coords.l, {mc = mc(coords.l.lc, coords.l.rc), c = arcL.platform.c}),
                        hasLower = arcL.hasLower,
                        hasUpper = arcL.hasUpper,
                    },
                    {
                        platform = func.with(coords.r, {mc = mc(coords.r.lc, coords.r.rc), c = arcR.platform.c}),
                        hasLower = arcR.hasLower,
                        hasUpper = arcR.hasUpper,
                    }
                }
            end
        end)
        * pipe.flatten()
                
    local transZ = coor.transZ(-config.hPlatform - 0.53 - 7.5)
    
    local idxPt = allArcs
        * pipe.zip(func.seq(1, #allArcs), {"p", "i"})
        * pipe.filter(function(a) return #(a.p) > 1 end)
        * pipe.map(pipe.select("i"))
    
    local fst = func.min(idxPt, function(l, r) return l < r end)
    local lst = func.max(idxPt, function(l, r) return l < r end)
    
    local accessBuilder = function()
        local transZ = coor.transZ(-config.hPlatform - 0.53)
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local enabler = entryConfig.underground[i]
                local pl = p.platform
                local lpt = pipe.new
                    / (p.hasLower and pl.lc[pl.c - 2 - floor(pl.c * 0.5)])
                    / pl.lc[pl.c]
                    / (p.hasUpper and pl.lc[pl.c + 2 + floor(pl.c * 0.5)])
                
                local rpt = pipe.new
                    / (p.hasLower and pl.rc[pl.c - 2 - floor(pl.c * 0.5)])
                    / pl.rc[pl.c]
                    / (p.hasUpper and pl.rc[pl.c + 2 + floor(pl.c * 0.5)])
                return pipe.mapn(lpt, rpt, enabler)(function(l, r, e)
                    return l and r and e and {pt = (i == 1 and l or r) .. transZ, vec = (i == 1 and (l - r) or (r - l)):withZ(0):normalized()}
                end)
            end)
            * function(ls) return func.map({1, 2, 3}, function(i) return ls * pipe.map(pipe.select(i)) end) end
            * pipe.map(function(ls)
                return pipe.new
                    / (
                    ls[1] and station.newModel(config.models.underground,
                        coor.rotZ(-0.5 * pi),
                        coor.transX(fst == 1 and -0.5 or (fst - 1) * config.wTrack),
                        ust.mRot(ls[1].vec),
                        coor.trans(ls[1].pt)
                    ))
                    / (ls[2] and station.newModel(config.models.underground,
                        coor.rotZ(-0.5 * pi),
                        coor.transX(#allArcs == lst and -0.5 or -0.5 + (#allArcs - lst) * config.wTrack),
                        ust.mRot(ls[2].vec),
                        coor.trans(ls[2].pt)
                    ))
                    * pipe.filter(pipe.noop())
            end)
            * pipe.flatten()
            * pipe.filter(pipe.noop())
    end
    
    local terrainBuilder = function()
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local enabler = entryConfig.underground[i]
                local pl = p.platform
                local lpt = pipe.new
                    / (p.hasLower and pl.lc[pl.c - 2 - floor(pl.c * 0.5)])
                    / pl.lc[pl.c]
                    / (p.hasUpper and pl.lc[pl.c + 2 + floor(pl.c * 0.5)])
                
                local rpt = pipe.new
                    / (p.hasLower and pl.rc[pl.c - 2 - floor(pl.c * 0.5)])
                    / pl.rc[pl.c]
                    / (p.hasUpper and pl.rc[pl.c + 2 + floor(pl.c * 0.5)])
                
                return pipe.mapn(lpt, rpt, enabler)(function(l, r, e)
                    return l and r and e and {pt = (i == 1 and l or r) .. transZ, vec = (i == 1 and (l - r) or (r - l)):withZ(0):normalized()}
                end)
            end)
            * function(ls) return func.map({1, 2, 3}, function(i) return ls * pipe.map(pipe.select(i)) end) end
            * pipe.map(function(ls)
                local vec1 = ls[1] and (ls[1].vec .. coor.rotZ(0.5 * pi)) * 4
                local vec2 = ls[2] and (ls[2].vec .. coor.rotZ(0.5 * pi)) * 4
                
                return pipe.new
                    / (
                    ls[1] and
                    {
                        ls[1].pt + vec1 + ls[1].vec * ((fst - 1) * config.wTrack - 2),
                        ls[1].pt - vec1 + ls[1].vec * ((fst - 1) * config.wTrack - 2),
                        ls[1].pt - vec1 + ls[1].vec * ((fst - 1) * config.wTrack + 18),
                        ls[1].pt + vec1 + ls[1].vec * ((fst - 1) * config.wTrack + 18)
                    })
                    / (ls[2] and {
                        ls[2].pt + vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack - 2),
                        ls[2].pt - vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack - 2),
                        ls[2].pt - vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack + 18),
                        ls[2].pt + vec2 + ls[2].vec * ((#allArcs - lst) * config.wTrack + 18)
                    })
                    * pipe.filter(pipe.noop())
            end)
            * pipe.flatten()
            * function(f)
                return pipe.new /
                    {
                        less = f * pipe.map(pipe.map(function(c) return c .. coor.transZ(0.53 + 7.5) end)) * pipe.map(station.finalizePoly),
                        slot = f * pipe.map(station.finalizePoly),
                        greater = f * pipe.map(station.finalizePoly)
                    }
            end
    end
    
    local streetBuilder = function()
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.mapi(function(p, i)
                local enabler = entryConfig.underground[i]
                
                local pl = p.platform
                local lpt = pipe.new
                    / (p.hasLower and pl.lc[pl.c - 2 - floor(pl.c * 0.5)])
                    / pl.lc[pl.c]
                    / (p.hasUpper and pl.lc[pl.c + 2 + floor(pl.c * 0.5)])
                
                local rpt = pipe.new
                    / (p.hasLower and pl.rc[pl.c - 2 - floor(pl.c * 0.5)])
                    / pl.rc[pl.c]
                    / (p.hasUpper and pl.rc[pl.c + 2 + floor(pl.c * 0.5)])
                
                return pipe.mapn(lpt, rpt, enabler)(function(l, r, e)
                    return l and r and {pt = l:avg(r) .. transZ, vec = (i == 1 and (l - r) or (r - l)):withZ(0) * 0.5, enabled = e}
                end)
            end)
            * function(ls) return func.map({1, 2, 3}, function(i) return ls * pipe.map(pipe.select(i)) end) end
            * pipe.map(pipe.filter(pipe.noop()))
            * pipe.filter(function(ls) return #ls > 0 end)
            * pipe.map(function(ls)
                local underground = pipe.new
                    / (ls[1] and ls[1].enabled and {
                        ls[1].pt,
                        ls[1].pt + (fst == 1
                        and ls[1].vec + ls[1].vec:normalized() * (-0.5)
                        or ls[1].vec + ls[1].vec:normalized() * (-0.5 + (fst - 1) * config.wTrack)),
                        ls[1].vec,
                        ls[1].vec,
                    })
                    / (ls[2] and ls[2].enabled and {
                        ls[2].pt,
                        ls[2].pt + (#allArcs == lst
                        and ls[2].vec + ls[2].vec:normalized() * (-0.5)
                        or ls[2].vec + ls[2].vec:normalized() * (-0.5 + (#allArcs - lst) * config.wTrack)),
                        ls[2].vec,
                        ls[2].vec,
                    })
                    / (((ls[1] and ls[1].enabled) or (ls[2] and ls[2].enabled)) and #arcCoords > 1 and ((ls[1].pt - ls[2].pt):length() > 1e-6) and
                    {
                        ls[1].pt,
                        ls[2].pt,
                        -ls[1].vec,
                        ls[2].vec,
                    }
                )

                local surface = underground
                    * pipe.range(1, 2)
                    * pipe.filter(pipe.noop())
                    * pipe.map(function(e) return {e[2], e[2] + e[3]:normalized() * 8, e[3], e[3]} end)
                    * pipe.range(i == 1 and 2 or 1, 2)
                
                return {
                    underground = underground * pipe.filter(pipe.noop()),
                    surface = surface,
                    surface2 = surface * pipe.map(function(e) return {e[2], e[2] + e[3]:normalized() * 10, e[3], e[3]} end)
                }
            end)
            * function(ls)
                local ug = ls * pipe.map(function(ls) return {
                    edge = ls.underground,
                    snap = pipe.new * pipe.rep(#ls.underground)({false, false})
                } end)
                local su = ls * pipe.map(function(ls) return {
                    edge = ls.surface,
                    snap = pipe.new * pipe.rep(#ls.surface)({false, false})
                } end)
                
                local su2 = ls * pipe.map(function(ls) return {
                    edge = ls.surface2,
                    snap = pipe.new * pipe.rep(#ls.surface2)({false, true})
                } end)

                
                return
                    {
                        pipe.new * {ug * station.mergeEdges} * station.prepareEdges * pipe.with(
                            {
                                type = "STREET",
                                edgeType = "TUNNEL",
                                edgeTypeName = "ust_void.lua",
                                params =
                                {
                                    type = "ust_pass.lua",
                                    tramTrackType = "NO"
                                }
                            }
                        ),
                        pipe.new * {su * station.mergeEdges} * station.prepareEdges * pipe.with(
                            {
                                type = "STREET",
                                alignTerrain = false,
                                params =
                                {
                                    type = "ust_pass.lua",
                                    tramTrackType = "NO"
                                }
                            }
                        ),
                        pipe.new * {su2 * station.mergeEdges} * station.prepareEdges * pipe.with(
                            {
                                type = "STREET",
                                alignTerrain = false,
                                params =
                                {
                                    type = "ust_pass_2.lua",
                                    tramTrackType = "NO"
                                }
                            }
                    )
                    }
            end
    end
    
    local laneBuilder = function()
        local function strCoor(l, r, b)
            local vec = (r - l):withZ(0):normalized() * 1.5 .. coor.rotZ(0.5 * pi)
            local ref = l:avg(r) .. transZ
            return {
                ust.unitLane(ref - vec, b),
                ust.unitLane(ref + vec, ref - vec),
            }
        end
        
        return pipe.new
            * {arcCoords[1], arcCoords[#arcCoords]}
            * pipe.map(function(p)
                local pl, la = p.platform, p.lane
                local fplc = floor(pl.c * 0.5)
                return pipe.new
                    / (p.hasUpper and (entryConfig.underground[1][3] or entryConfig.underground[2][3]) and strCoor(
                        pl.lc[pl.c + 2 + fplc],
                        pl.rc[pl.c + 2 + fplc],
                        pl.mc[pl.c + 3 + fplc] - coor.xyz(0, 0, 3.5)
                    ))
                    / (p.hasLower and (entryConfig.underground[1][1] or entryConfig.underground[2][1]) and strCoor(
                        pl.rc[pl.c - 2 - fplc],
                        pl.lc[pl.c - 2 - fplc],
                        pl.mc[pl.c - 3 - fplc] - coor.xyz(0, 0, 3.5)
                    ))
                    / ((entryConfig.underground[1][2] or entryConfig.underground[2][2]) and strCoor(
                        pl.lc[pl.c],
                        pl.rc[pl.c],
                        pl.mc[pl.c + 2] - coor.xyz(0, 0, 3.5)
                    ))
                    / ((entryConfig.underground[1][2] or entryConfig.underground[2][2]) and strCoor(
                        pl.rc[pl.c],
                        pl.lc[pl.c],
                        pl.mc[pl.c - 2] - coor.xyz(0, 0, 3.5)
                    ))
                    * pipe.filter(pipe.noop())
            end)
            * pipe.flatten()
            * pipe.flatten()
    end
    
    return {
        access = accessBuilder(),
        lane = laneBuilder(),
        terrain = terrainBuilder(),
        street = streetBuilder()
    }
end


local buildEntry = function(config, entryConfig, retriveRef)
    local allArcs = entryConfig.allArcs
    local gArcs = pipe.new * {ust.trackGrouping(pipe.new, table.unpack(allArcs))}
    local arcCoords = gArcs
        * pipe.map(pipe.filter(function(a) return #a > 1 end))
        * pipe.filter(function(g) return #g == 1 end)
        * pipe.flatten()
    
    local mixedCoords =
        gArcs
        * pipe.map(pipe.filter(function(a) return #a > 1 end))
        * pipe.filter(function(g) return #g > 1 end)
        * (function(ls) return table.unpack(ls) end)
    
    local retriveRef = retriveRef or function()
        local refArc = #arcCoords > 0 and arcCoords[1] or mixedCoords[1]
        
        local pl, la, su = refArc.platform, refArc.lane, refArc.surface
        local f = pipe.exec * function()
            if (entryConfig.main.pos == 0 or not entryConfig.main.model) then
                return function(set) return set.c end
            elseif (entryConfig.main.pos < 0) then
                return function(set) return set.c - 3 - floor(set.c * 0.5) end
            else
                return function(set) return set.c + 3 + floor(set.c * 0.5) end
            end
        end
        local refPt = la.lc[f(la)]
        return refPt, ust.mRot((su.lc[f(su)] - pl.lc[f(pl)]):normalized()), la.lc[f(la)], pl.lc[f(pl)]:avg(pl.rc[f(pl)])
    end
    
    local refPt, refMRot, cpt, cupt = retriveRef()
    
    local laneBuilder = function()
        local function retrive(pl, la)
            local flac = floor(la.c * 0.5)
            local fplc = floor(pl.c * 0.5)
            local ref = {
                n = pl.c > 5 and {l = la.c - 2, p = pl.c - 4} or {l = la.c - 1, p = pl.c - 2},
                p = pl.c > 5 and {l = la.c + 2, p = pl.c + 4} or {l = la.c + 1, p = pl.c + 2}
            }
            return flac, fplc, ref
        end
        
        local fn = function(p)
            local pl, la = p.platform, p.lane
            local flac, fplc, ref = retrive(pl, la)
            
            return pipe.new / ust.unitLane(la.mc[ref.n.l - 2]:avg(la.mc[ref.n.l - 3]), pl.mc[ref.n.p]) /
                ust.unitLane(la.mc[ref.p.l + 2]:avg(la.mc[ref.p.l + 3]), pl.mc[ref.p.p]) +
                (p.hasLower
                and {ust.unitLane(la.mc[la.c - 5 - flac]:avg(la.mc[la.c - 4 - flac]), pl.mc[pl.c - 4 - fplc])}
                or
                {})
                + (p.hasUpper
                and {ust.unitLane(la.mc[la.c + 5 + flac]:avg(la.mc[la.c + 4 + flac]), pl.mc[pl.c + 4 + fplc])} or
                {})
                + func.map(
                    il(func.range(pl.mc, pl.c - 3, pl.c + 3)),
                    function(c)
                        local b = c.i
                        local t = c.s
                        local vec = t - b
                        return station.newModel("ust/person_lane.mdl", ust.mRot(vec), coor.trans(b), coor.transZ(-3.5))
                    end
        )
        end
        
        local fn2 = function()
            local l, r = table.unpack(mixedCoords)
            local function seperated(p)
                local pl, la = p.platformO, p.lane
                local flac, fplc, ref = retrive(pl, la)
                
                return pipe.new + ((pl.intersection < (ref.n.l - 2)) and {ust.unitLane(la.mc[ref.n.l - 2]:avg(la.mc[ref.n.l - 3]), pl.mc[ref.n.p])} or {}) +
                    ((pl.intersection < (ref.p.l + 2)) and {ust.unitLane(la.mc[ref.p.l + 2]:avg(la.mc[ref.p.l + 3]), pl.mc[ref.p.p])} or {}) +
                    (p.hasLower and (pl.intersection < (pl.c - 4 - fplc)) and
                    {
                        ust.unitLane(la.mc[la.c - 5 - flac]:avg(la.mc[la.c - 4 - flac]), pl.mc[pl.c - 4 - fplc])
                    } or
                    {})
                    +
                    (p.hasUpper and (pl.intersection < (pl.c + 4 + fplc)) and
                    {
                        ust.unitLane(la.mc[la.c + 5 + flac]:avg(la.mc[la.c + 4 + flac]), pl.mc[pl.c + 4 + fplc])
                    } or
                    {})
                    +
                    ((pl.intersection < pl.c + 3) and
                    func.map(
                        il(func.range(pl.mc, func.max({pl.intersection, pl.c - 3}), pl.c + 3)),
                        function(c)
                            local b = c.i
                            local t = c.s
                            local vec = t - b
                            return station.newModel("ust/person_lane.mdl", ust.mRot(vec), coor.trans(b), coor.transZ(-3.5))
                        end
                    ) or
                    {})
            end
            
            local combined = function()
                local pl = {mc = func.map2(l.platformO.lc, r.platformO.rc, function(l, r) return l:avg(r) end), c = l.platformO.c, intersection = l.platformO.intersection}
                local la = {mc = func.map2(l.lane.lc, r.lane.rc, function(l, r) return l:avg(r) end), c = l.lane.c, intersection = l.lane.intersection}
                local flac, fplc, ref = retrive(pl, la)
                
                return pipe.new + ((pl.intersection > (ref.n.l - 2)) and {ust.unitLane(la.mc[ref.n.l - 2]:avg(la.mc[ref.n.l - 3]), pl.mc[ref.n.p])} or {}) +
                    ((pl.intersection > (ref.p.l + 2)) and {ust.unitLane(la.mc[ref.p.l + 2]:avg(la.mc[ref.p.l + 3]), pl.mc[ref.p.p])} or {}) +
                    (l.hasLower and (pl.intersection > (pl.c - 4 - fplc)) and
                    {
                        ust.unitLane(la.mc[la.c - 5 - flac]:avg(la.mc[la.c - 4 - flac]), pl.mc[pl.c - 4 - fplc])
                    } or
                    {})
                    +
                    (l.hasUpper and (pl.intersection > (pl.c + 4 + fplc)) and
                    {
                        ust.unitLane(la.mc[la.c + 5 + flac]:avg(la.mc[la.c + 4 + flac]), pl.mc[pl.c + 4 + fplc])
                    } or
                    {})
                    +
                    ((pl.intersection > pl.c - 3) and
                    func.map(
                        il(func.range(pl.mc, pl.c - 3, func.min({pl.intersection, pl.c + 3}))),
                        function(c)
                            local b = c.i
                            local t = c.s
                            local vec = t - b
                            return station.newModel("ust/person_lane.mdl", ust.mRot(vec), coor.trans(b), coor.transZ(-3.5))
                        end
                    ) or
                    {})
                    +
                    ((pl.intersection > pl.c - 3) and (pl.intersection < pl.c + 3) and {
                        station.newModel("ust/person_lane.mdl", ust.mRot(l.platformO.mc[pl.intersection] - pl.mc[pl.intersection]), coor.trans(pl.mc[pl.intersection]), coor.transZ(-3.5)),
                        station.newModel("ust/person_lane.mdl", ust.mRot(r.platformO.mc[pl.intersection] - pl.mc[pl.intersection]), coor.trans(pl.mc[pl.intersection]), coor.transZ(-3.5))
                    } or {})
            end
            
            return seperated(l) + seperated(r) + combined()
        end
        
        return arcCoords
            * pipe.map(fn)
            * pipe.flatten()
            + (mixedCoords and (pipe.exec * fn2) or {})
            +
            gArcs
            * pipe.map(pipe.filter(function(a) return #a > 1 end))
            * pipe.map(function(g)
                if (#g == 1) then
                    local f = function(p)
                        local pl = p.platform
                        local fplc = floor(pl.c * 0.5)
                        return pipe.new / (pl.mc[pl.c] + coor.xyz(0, 0, -3.5)) /
                            (p.hasUpper and pl.mc[pl.c + 3 + fplc] - coor.xyz(0, 0, 3.5)) /
                            (p.hasLower and pl.mc[pl.c - 3 - fplc] - coor.xyz(0, 0, 3.5))
                    end
                    return {f(g[1])}
                else
                    local function retrive(pl, la)
                        local flac = floor(la.c * 0.5)
                        local fplc = floor(pl.c * 0.5)
                        local ref = {
                            n = pl.c > 5 and {l = la.c - 2, p = pl.c - 4} or {l = la.c - 1, p = pl.c - 2},
                            p = pl.c > 5 and {l = la.c + 2, p = pl.c + 4} or {l = la.c + 1, p = pl.c + 2}
                        }
                        return flac, fplc, ref
                    end
                    local function x(p)
                        local pl, la = p.platformO, p.lane
                        local flac, fplc, ref = retrive(pl, la)
                        return pipe.new
                            / (pl.intersection < (ref.n.l - 2) and (pl.mc[pl.c] + coor.xyz(0, 0, -3.5)))
                            / (p.hasUpper and (pl.intersection < (pl.c + 4 + fplc)) and pl.mc[pl.c + 3 + fplc] - coor.xyz(0, 0, 3.5))
                            / (p.hasLower and (pl.intersection < (pl.c - 4 - fplc)) and pl.mc[pl.c - 3 - fplc] - coor.xyz(0, 0, 3.5))
                    end
                    local combined = function(l, r)
                        local pl = {mc = func.map2(l.platformO.lc, r.platformO.rc, function(l, r) return l:avg(r) end), c = l.platformO.c, intersection = l.platformO.intersection}
                        local la = {mc = func.map2(l.lane.lc, r.lane.rc, function(l, r) return l:avg(r) end), c = l.lane.c, intersection = l.lane.intersection}
                        local flac, fplc, ref = retrive(pl, la)
                        
                        return pipe.new
                            / (pl.intersection > (ref.n.l - 2) and (pl.mc[pl.c] + coor.xyz(0, 0, -3.5)))
                            / (l.hasUpper and (pl.intersection > (pl.c + 4 + fplc)) and pl.mc[pl.c + 3 + fplc] - coor.xyz(0, 0, 3.5))
                            / (l.hasLower and (pl.intersection > (pl.c - 4 - fplc)) and pl.mc[pl.c - 3 - fplc] - coor.xyz(0, 0, 3.5))
                    end
                    return {x(g[1]), x(g[2]), combined(table.unpack(g))}
                end
            end)
            * pipe.flatten()
            * (function(ls) return {ls * pipe.map(pipe.select(1)), ls * pipe.map(pipe.select(2)), ls * pipe.map(pipe.select(3))} end)
            * pipe.map(pipe.filter(pipe.noop()))
            * pipe.map(pipe.interlace({"l", "r"}))
            * pipe.map(pipe.map(function(pt) return station.newModel("ust/person_lane.mdl", ust.mRot((pt.l - pt.r)), coor.trans(pt.r)) end))
            * pipe.flatten()
    end
    
    local accessBuilder = function()
        local mx = coor.transX(-config.buildingParams.xOffset) * refMRot * coor.trans(refPt)
        local m = coor.rotX(atan(-config.slope)) * mx
        return pipe.new *
            func.map(config.buildingParams.platform, function(p) return ust.unitLane(p .. m, cpt) end)
            + func.map(config.buildingParams.entry, function(p) return ust.unitLane(p .. m, coor.xyz(-10, p.y > 0 and 4.5 or -4.5, -0.8) .. mx) end)
            + func.map(config.buildingParams.pass, function(p) return ust.unitLane(p .. m, cupt - coor.xyz(0, 0, 3.5)) end)
            + {station.newModel(entryConfig.main.model, coor.rotZ(-pi * 0.5), m, coor.transZ(-0.78))}
    end
    
    local streetBuilder = function()
        local mVe = refMRot
        local mPt = coor.transX(-config.buildingParams.xOffset) * mVe * coor.trans(refPt)
        local mainAccess = {
            edge = pipe.new /
            {
            (config.buildingParams.street .. mPt):withZ(refPt.z - 0.8),
                ((config.buildingParams.street - coor.xyz(20, 0, 0)) .. mPt):withZ(refPt.z - 0.8),
                coor.xyz(-1, 0, 0) .. mVe,
                coor.xyz(-1, 0, 0) .. mVe
            },
            snap = pipe.new / {false, true}
        }
        
        return pipe.new /
            (pipe.new * {mainAccess} * station.prepareEdges *
            pipe.with(
                {
                    type = "STREET",
                    params = {
                        type = "station_new_small.lua",
                        tramTrackType = "NO"
                    }
                }
    ))
    end
    
    local terrainBuilder = function()
        local z = -0.8
        local mRot = coor.rotX(atan(-config.slope))
        local mX = coor.transX(-config.buildingParams.xOffset) * refMRot * coor.trans(refPt)
        local xMin = config.buildingParams.street.x
        local xMax = config.buildingParams.xOffset
        local yMin = -config.buildingParams.halfWidth
        local yMax = config.buildingParams.halfWidth
        return pipe.new
            / {
                equal = pipe.new
                / {
                    coor.xyz(config.buildingParams.entry[1].x, yMin, z) .. mRot * mX,
                    coor.xyz(xMax, yMin, z) .. mRot * mX,
                    coor.xyz(xMax, yMax, z) .. mRot * mX,
                    coor.xyz(config.buildingParams.entry[1].x, yMax, z) .. mRot * mX
                }
                / {
                    coor.xyz(config.buildingParams.street.x, yMin, z) .. mX,
                    coor.xyz(config.buildingParams.entry[1].x, yMin, z) .. mRot * mX,
                    coor.xyz(config.buildingParams.entry[1].x, yMax, z) .. mRot * mX,
                    coor.xyz(config.buildingParams.street.x, yMax, z) .. mX
                }
                * pipe.map(station.finalizePoly)
            }
    end
    
    local hasMain = entryConfig.main.model
    
    return {
        access = hasMain and accessBuilder() or {},
        lane = laneBuilder(),
        terrain = hasMain and terrainBuilder() or {},
        street = hasMain and streetBuilder() or {}
    }
end

local buildStation = function(nbTracksA, nbTracksB, arcPackerA, arcPackerB, config, hasFirst, hasCentral, hasLast)
    local pW = config.wPlatform
    local tW = config.wTrack
    local bandWidth = 0.8
    local pWe = config.wExtPlatform * (pW - bandWidth * 2) + bandWidth * 2
    local fitModel = slope == 0 and ust.fitModel2D or ust.fitModel
    
    local ptListA = ust.preBuild(nbTracksA, config.nbTransitTracksA, config.posTransitTracksA, not hasCentral, not hasFirst)(nbTracksA, pipe.new) * pipe.rev()
    local ptListB = ust.preBuild(nbTracksB, config.nbTransitTracksB, config.posTransitTracksB, not hasCentral, not hasLast)(nbTracksB, pipe.new)
    
    local ptListIA = ptListA * pipe.range(1, #ptListA - (hasCentral and 1 or 0)) * pipe.zip(func.seq(1, #ptListA), {"t", "i"})
    local ptListIB = ptListB * pipe.range(hasCentral and 2 or 1, #ptListB) * pipe.zip(func.seq(#ptListA + 1, #ptListA + #ptListB + 1), {"t", "i"})
    
    local middlePos = hasCentral and #ptListA or (#ptListA + 0.5)
    local leftGroup = ptListIA * pipe.rev()
    local middleGroup = pipe.new * (hasCentral and {{i = #ptListA, t = false}} or {})
    local rightGroup = ptListIB
    
    local platformArcGen = ust.platformArcGen(tW, pW)
    
    local lengthFn = function(posPct)
        return 1 - (1 - config.lExtPlatform) * ust.varFn(config.lExtPlatform)[config.varModelLength](posPct)
    end
    local widthFn = function(posPct)
        return (1 - (1 - config.wExtPlatform) * ust.varFn(config.wExtPlatform)[config.varModelWidth](posPct)) * (pW - bandWidth * 2) + bandWidth * 2
    end
    
    local function generateArcs(init, initDr, initX)
        local function arcGen(result, r, o, isRight)
            return isRight and
                function(t, ...)
                    if t == nil then
                        return result
                            * pipe.sort(function(l, r) return l.i < r.i end)
                            * pipe.map(pipe.select("a"))
                            * pipe.fold(pipe.new, function(r, a) return #a == 4 and (r / {a[1], a[3]} / {a[4], a[2]}) or (r / a) end)
                    else
                        local posPct = abs(t.i - middlePos) / (#rightGroup)
                        local isVar = posPct >= config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and -posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPackerB(r - tW, o, isVar and lengthPct or 1, offsetPct)}}, r - tW, o, true)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(
                                    result /
                                    {
                                        i = t.i,
                                        a = {
                                            arcPackerB(r - (0.5 * tW), o, lengthPct, offsetPct),
                                            arcPackerB(r - (0.5 * tW + pW), o, lengthPct, offsetPct)
                                        }
                                    },
                                    r - pW,
                                    o,
                                    true
                                )(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local r, o, a = platformArcGen(arcPackerB)(r, o, lengthPct, offsetPct, pWe, true)
                                return arcGen(result / {i = t.i, a = a}, r, o, true)(...)
                            end
                        end
                    end
                end or
                function(t, ...)
                    if t == nil then
                        return arcGen(result, initDr[#initDr], initX[#initX], true)(table.unpack(rightGroup))
                    else
                        local posPct = abs(t.i - middlePos) / (#leftGroup)
                        local isVar = posPct >= config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPackerA(r + tW, o, lengthPct, offsetPct)}}, r + tW, o)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(
                                    result /
                                    {
                                        i = t.i,
                                        a = {
                                            arcPackerA(r + (0.5 * tW + pW), o, lengthPct, offsetPct),
                                            arcPackerA(r + (0.5 * tW), o, lengthPct, offsetPct)
                                        }
                                    },
                                    r + pW,
                                    o
                                )(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local r, o, a = platformArcGen(arcPackerA)(r, o, lengthPct, offsetPct, pWe, false)
                                return arcGen(result / {i = t.i, a = a}, r, o)(...)
                            end
                        end
                    end
                end
        end
        local rs = arcGen(init, initDr[1], initX[1])(table.unpack(leftGroup))
        return rs
    end
    local allArcs =
        pipe.exec *
        function()
            local oA = coor.xyz(config.rA, 0, 0)
            local oB =
                coor.xyz(config.rB, 0, 0) + coor.xyz(cos(config.convRad) - 1, sin(config.convRad), 0) * config.rB +
                coor.xyz(1 - cos(config.convRad), sin(config.convRad), 0) * pW
            if (hasCentral) then
                local arcA = arcPackerA(config.rA + 0.5 * pW, oA)
                local arcB = arcPackerB(config.rB - 0.5 * pW, oB)
                local _, _, arcAi = platformArcGen(arcPackerA)(config.rA + 0.5 * pW + 0.5 * tW, oA, 1, 0, pWe, true)
                local _, _, arcBi = platformArcGen(arcPackerB)(config.rB - 0.5 * pW + 0.5 * tW, oB, 1, 0, pWe, false)
                return generateArcs(
                    pipe.new /
                    {
                        i = middlePos,
                        a = {
                            arcA,
                            arcB,
                            arcAi[2],
                            arcBi[2]
                        }
                    },
                    {
                        config.rA - (-0.5 * pW + 0.5 * tW),
                        config.rB - (0.5 * pW - 0.5 * tW)
                    },
                    {oA, oB}
            )
            else
                return generateArcs(
                    pipe.new * {},
                    {
                        config.rA - (0.5 * tW),
                        config.rB - (-0.5 * tW)
                    },
                    {oA, oB}
            )
            end
        end
        * ust.allArcs(arcGen, config)
        * function(allArcs)
            for i = 1, #allArcs - 1 do
                if #allArcs[i] > 1 and #allArcs[i + 1] > 1 then
                    local arcsL, arcsR = allArcs[i], allArcs[i + 1]
                    local greater = function(x, y) return x > y and x or y end
                    
                    
                    local retriveBaseParams = function(arcsL, arcsR)
                        local intersection = greater(ust.coordIntersection(arcsL.rc, arcsR.lc))
                        
                        local max = arcsL.c > arcsR.c and 2 * (arcsR.c - 1) or 2 * (arcsL.c - 1)
                        local r =
                            pipe.new
                            * (pipe.mapn(
                                func.seq(intersection, max),
                                arcsL.rc * pipe.range(intersection, max + 1) * il,
                                arcsR.lc * pipe.range(intersection, max + 1) * il
                            )
                            (function(i, l, r)
                                local vecL = (l.i - l.s):withZ(0)
                                local vecR = (r.i - l.s):withZ(0)
                                local vec = (r.s - l.s):withZ(0)
                                return vec:cross(vecL).z > 0 and vec:cross(vecR).z < 0 and i or false
                            end
                            ))
                            * pipe.filter(pipe.noop())
                            * function(r) return #r > 0 and r[#r] or max end
                        return intersection, intersection + floor(config.lengthMiddlePlatform * (r - intersection))
                    end
                    
                    local intersection, commonLength = retriveBaseParams(arcsL.platform, arcsR.platform)
                    
                    local ln = line.byPtPt(arcsL.surface.rc[commonLength + 1], arcsR.surface.lc[commonLength + 1])
                    local retriveParams = function(arcsL, arcsR)
                        local intersection = greater(ust.coordIntersection(arcsL.rc, arcsR.lc))
                        local max = arcsL.c > arcsR.c and 2 * (arcsR.c - 1) or 2 * (arcsL.c - 1)
                        local commonLength =
                            pipe.exec
                            * function()
                                local r =
                                    pipe.new
                                    * (pipe.mapn(
                                        func.seq(intersection, max - 1),
                                        arcsL.rc * pipe.range(intersection, max) * il,
                                        arcsR.lc * pipe.range(intersection, max) * il
                                    )
                                    (function(i, l, r)
                                        local xL = line.byPtPt(l.i, l.s) - ln
                                        local xR = line.byPtPt(r.i, r.s) - ln
                                        return ((l.i - xL):dot(l.s - xL) < 0 or (r.i - xR):dot(r.s - xR) < 0) and i or false
                                    end)
                                    )
                                    * pipe.filter(pipe.noop())
                                    * function(r) return #r > 0 and r[1] or max end
                                return floor(r)
                            end
                        return intersection, commonLength
                    end
                    
                    local roofIntersection, roofCommonLength = retriveParams(arcsL.roof.edge, arcsR.roof.edge)
                    local roofPoleIntersection = retriveBaseParams(arcsL.roof.pole, arcsR.roof.pole)
                    local chairIntersection = retriveBaseParams(arcsL.chair, arcsR.chair)
                    local laneIntersection, laneCommonLength = retriveParams(arcsL.laneEdge, arcsR.laneEdge)
                    
                    
                    local ptL = arcsL.surface.lc[intersection]
                    local ptR = arcsR.surface.rc[intersection]
                    local vec = ptR - ptL
                    
                    local lL = (arcsL.surface.lc[intersection + 1] - arcsL.surface.rc[intersection + 1]):length()
                    local rL = (arcsR.surface.lc[intersection + 1] - arcsR.surface.rc[intersection + 1]):length()
                    local mL = (arcsR.surface.lc[intersection + 1] - arcsL.surface.rc[intersection + 1]):length()
                    
                    arcsL.platform.intersection = intersection
                    arcsR.platform.intersection = intersection
                    arcsL.lane.intersection = laneIntersection
                    arcsR.lane.intersection = laneIntersection
                    arcsL.terrain.intersection = intersection
                    arcsR.terrain.intersection = intersection
                    
                    arcsL.lane.common = laneCommonLength
                    arcsR.lane.common = laneCommonLength
                    arcsL.platform.common = commonLength
                    arcsR.platform.common = commonLength
                    arcsL.terrain.common = commonLength
                    arcsR.terrain.common = commonLength
                    
                    arcsL.platformO = func.with(arcsL.platform, {})
                    arcsR.platformO = func.with(arcsR.platform, {})
                    arcsL.platform.rc = func.with(arcsL.platform.rc, {[intersection] = ptL + vec * (lL / (lL + rL + mL))})
                    arcsR.platform.lc = func.with(arcsR.platform.lc, {[intersection] = ptL + vec * ((mL + lL) / (lL + rL + mL))})
                    arcsL.surface.rc = func.with(arcsL.surface.rc, {[intersection] = arcsL.platform.rc[intersection] - vec:normalized() * 0.8})
                    arcsR.surface.lc = func.with(arcsR.surface.lc, {[intersection] = arcsR.platform.lc[intersection] + vec:normalized() * 0.8})
                    
                    if (config.roofLength > 0) then
                        local ptL = arcsL.roof.edge.lc[roofIntersection]
                        local ptR = arcsR.roof.edge.rc[roofIntersection]
                        local vec = ptR - ptL
                        
                        local lL = (arcsL.roof.edge.lc[roofIntersection + 1] - arcsL.roof.edge.rc[roofIntersection + 1]):length()
                        local rL = (arcsR.roof.edge.lc[roofIntersection + 1] - arcsR.roof.edge.rc[roofIntersection + 1]):length()
                        local mL = (arcsR.roof.edge.lc[roofIntersection + 1] - arcsL.roof.edge.rc[roofIntersection + 1]):length()
                        
                        arcsL.roof.intersection = roofIntersection
                        arcsL.roof.common = roofCommonLength
                        arcsR.roof.intersection = roofIntersection
                        arcsR.roof.common = roofCommonLength
                        arcsL.roof.edge.rc = func.with(arcsL.roof.edge.rc, {[roofIntersection] = ptL + vec * (lL / (lL + rL + mL))})
                        arcsR.roof.edge.lc = func.with(arcsR.roof.edge.lc, {[roofIntersection] = ptL + vec * ((mL + lL) / (lL + rL + mL))})
                        arcsL.roof.surface.rc = func.with(arcsL.roof.surface.rc, {[roofIntersection] = arcsL.roof.edge.rc[roofIntersection] - vec:normalized() * 0.8})
                        arcsR.roof.surface.lc = func.with(arcsR.roof.surface.lc, {[roofIntersection] = arcsR.roof.edge.lc[roofIntersection] + vec:normalized() * 0.8})
                        arcsL.roof.pole.intersection = roofPoleIntersection
                        arcsR.roof.pole.intersection = roofPoleIntersection
                        arcsL.chair.intersection = chairIntersection
                        arcsR.chair.intersection = chairIntersection
                    end
                end
            end
            return allArcs
        end
    
    local arcCoords = allArcs * pipe.filter(function(a) return #a > 1 end)
    local retriveRef = retriveRef(config, allArcs)
    
    local entryConfig = ust.entryConfig(config, allArcs, arcCoords, retriveRef)
    
    local build =
        ust.build(
            config,
            fitModel,
            pipe.new
            / buildEntry(config, entryConfig, retriveRef)
            / buildUndergroundEntry(config, entryConfig)
            / uste.buildSecondEntrySlope(config, entryConfig)
    )
    return build(pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, ust.trackGrouping(pipe.new, table.unpack(allArcs)))
end

local updateFn = function()
    return ust.safeBuild(
        params,
        function(params)
            local trackType = ustm.trackList[params.trackType + 1]
            local trackWidth = ustm.trackWidthList[params.trackType + 1]
            local catenary = params.catenary == 1
            local trackBuilder = trackEdge.builder(catenary, trackType)
            local hPlatform = ustm.hPlatformList[params.hPlatform + 1] * 0.001
            local wPlatform = ustm.wPlatformList[params.wPlatform + 1]
            local roofLength = ustm.roofLengthList[params.roofLength + 1] * 0.01
            local mainBuilding = params.entrySize > 0 and buildingList[params.entrySize]
            local fencesLength = ustm.fencesLengthList[params.fencesStyle + 1]
            local fencesModel = ust.fencesGen(params.fencesColor + 1, params.fencesStyle + 1)
            
            local nbTracksA = ustm.trackNumberList[params.nbTracksA + 1]
            local nbTracksB = ustm.trackNumberList[params.nbTracksB + 1]
            local radiusA = (ustm.rList[params.radiusA + 1] * 1000) * (params.curveLayout == 2 and 1 or -1)
            local radiusB = (ustm.rList[params.radiusB + 1] * 1000) * (params.curveLayout == 0 and -1 or 1)
            
            if (params.curveLayout == 0 and radiusA < radiusB) or (params.curveLayout == 2 and radiusA < radiusB) then
                radiusA, radiusB = radiusB, radiusA
            end
            
            local slope = ustm.slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
            
            local lengthA = min(ustm.trackLengths[params.lengthA + 1], abs(radiusA * pi * 1.5))
            local lengthB = min(ustm.trackLengths[params.lengthB + 1], abs(radiusB * pi * 1.5))
            
            local entryConfig = {
                main = {
                    pos = mainBuilding and (params.entryPos - 1),
                    model = mainBuilding
                },
                street = {
                    pipe.mapn(
                        {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1},
                        {params.entryASide < 2, params.entryBSide < 2, params.entryCSide < 2}
                        )(
                        function(t, v)
                            return t and v
                        end
                    ),
                    pipe.mapn(
                        {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1},
                        {params.entryASide > 0, params.entryBSide > 0, params.entryCSide > 0}
                        )(
                        function(t, v)
                            return t and v
                        end
                )
                },
                underground = {
                    pipe.mapn(
                        {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0},
                        {params.entryASide < 2, params.entryBSide < 2, params.entryCSide < 2}
                    )
                    (function(t, v) return t and v end),
                    pipe.mapn(
                        {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0},
                        {params.entryASide > 0, params.entryBSide > 0, params.entryCSide > 0}
                    )
                    (function(t, v) return t and v end)
                }
            }
            
            local edge, streetEdge, terminals, terminalsGroup, models, terrain =
                buildStation(
                    nbTracksA,
                    nbTracksB,
                    arcPacker(lengthA, slope, lengthA / radiusA * 0.5, 0),
                    arcPacker(lengthB, slope, lengthB / radiusB * 0.5, pi * ustm.convAngle[params.convAngle + 1] / 180),
                    {
                        nbTransitTracksA = params.nbTransitTracksA,
                        posTransitTracksA = params.posTransitTracksA,
                        nbTransitTracksB = params.nbTransitTracksB,
                        posTransitTracksB = params.posTransitTracksB,
                        convRad = pi * ustm.convAngle[params.convAngle + 1] / 180,
                        rA = radiusA,
                        rB = radiusB,
                        hPlatform = hPlatform,
                        wPlatform = wPlatform,
                        wExtPlatform = ustm.extWidthList[params.wExtPlatform + 1] * 0.01,
                        lExtPlatform = ustm.extLengthList[params.lExtPlatform + 1] * 0.01,
                        yOffsetPlatform = ustm.yOffsetList[params.yOffsetPlatform + 1] * (params.yOffsetPlatformSign == 0 and 0.01 or -0.01),
                        varNbUnaffected = ustm.varUnaffectedList[params.varNbUnaffected + 1] * 0.01,
                        varModelLength = params.varModelLength + 1,
                        varModelWidth = params.varModelWidth + 1,
                        wTrack = trackWidth,
                        roofLength = roofLength,
                        buildingParams = buildingParamsList[params.entrySize],
                        slope = slope,
                        fencesModel = fencesModel,
                        fencesLength = fencesLength,
                        leftFences = params.fencesPos == 1 or params.fencesPos == 3,
                        rightFences = params.fencesPos == 2 or params.fencesPos == 3,
                        entries = entryConfig,
                        models = models,
                        lengthMiddlePlatform = ustm.middlePlatformLength[params.lengthMiddlePlatform + 1] * 0.01
                    },
                    params.hasLeftPlatform == 1,
                    params.hasMiddlePlatform == 1,
                    params.hasRightPlatform == 1
            )
            return pipe.new *
                {
                    edgeLists = pipe.new / (pipe.new * {edge * station.mergeEdges} * station.prepareEdges * trackBuilder.normal()) + streetEdge,
                    models = terminals + models,
                    terminalGroups = terminalsGroup,
                    terrainAlignmentLists = station.mergePoly(table.unpack(terrain))(),
                    groundFaces = terrain * pipe.map(pipe.select("equal")) * pipe.filter(pipe.noop()) * pipe.flatten() *
                    pipe.map(
                        function(f)
                            return {
                                {face = f, modes = {{type = "FILL", key = "industry_gravel_small_01"}}},
                                {face = f, modes = {{type = "STROKE_OUTER", key = "building_paving"}}}
                            }
                        end
                    ) *
                    pipe.flatten()
                }
        end
)
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Triangle Station"),
            description = _("Station that platform and track parameters can be fine-tuned, with two different radii on two sides of the station.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0
        },
        order = 5013,
        params = params(),
        updateFn = updateFn()
    }
end
