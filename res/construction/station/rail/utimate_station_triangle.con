local paramsutil = require "paramsutil"
local func = require "ustation/func"
local coor = require "ustation/coor"
local line = require "ustation/coorline"
local arc = require "ustation/coorarc"
local trackEdge = require "ustation/trackedge"
local station = require "ustation/stationlib"
local pipe = require "ustation/pipe"
local ust = require "ustation"
local uste = require "ustation_entries"
local ustm = require "ustation_menu"
local ma = math

local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local min = ma.min
local e = ma.exp(1)
local log = ma.log
local log10 = log(10)

local prefixM = "ust/1990/"
local buildingList, buildingParamsList = require("ustation_building")(prefixM)
local models = ust.models(prefixM)

local function params()
    local sp = "·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·:·\n"
    return
        pipe.new
        + ustm.trackType
        +
        {
            {
                key = "nbTracksA",
                name = sp .. "\n" .. _("Number of tracks") .. "\n\n" .. "A",
                values = func.map(ustm.trackNumberList, tostring),
                defaultIndex = 1
            },
            {
                key = "nbTracksB",
                name = "B",
                values = func.map(ustm.trackNumberList, tostring),
                defaultIndex = 1
            },
            {
                key = "nbTransitTracksA",
                name = sp .. "\n" .. _("Transit Tracks") .. "\n\n" .. "A",
                values = func.map({0, 1, 2, 3, 4}, tostring),
                defaultIndex = 0
            },
            {
                key = "posTransitTracksA",
                name = _("Position"),
                values = {_("Centre"), _("Outter")},
                defaultIndex = 0
            },
            {
                key = "nbTransitTracksB",
                name = "\n" .. "B",
                values = func.map({0, 1, 2, 3, 4}, tostring),
                defaultIndex = 0
            },
            {
                key = "posTransitTracksB",
                name = _("Position"),
                values = {_("Centre"), _("Outter")},
                defaultIndex = 0
            },
            {
                key = "radiusA",
                name = sp .. "\n" .. _("Radius") .. " " .. "(m)" .. "\n\n" .. "A",
                values = pipe.from("∞") + func.map(func.range(ustm.rList, 2, #ustm.rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
                defaultIndex = 0
            },
            {
                key = "radiusB",
                name = "B",
                values = pipe.from("∞") + func.map(func.range(ustm.rList, 2, #ustm.rList), function(r) return tostring(math.floor(r * 1000 + 0.5)) end),
                defaultIndex = 0
            },
            {
                key = "curveLayout",
                name = _("Polarity"),
                values = {"--", "-+", "++"},
                defaultIndex = 1
            },
            {
                key = "lengthA",
                name = sp .. "\n" .. _("Platform") .. "\n\n" .. _("Length") .. " " .. "(m)" .. "\n\n" .. "A",
                values = func.map(ustm.trackLengths, tostring),
                defaultIndex = 5
            },
            {
                key = "lengthB",
                name = "B",
                values = func.map(ustm.trackLengths, tostring),
                defaultIndex = 5
            }
        }
        + ustm.platform
        +
        {
            {
                key = "lengthMiddlePlatform",
                name = _("Central Platform Length") .. "(%)",
                values = func.map(ustm.middlePlatformLength, tostring),
                defaultIndex = 3
            },
        }
        + ustm.exclu("varRefType", "varRefPos")(ustm.var)
        + ustm.slope
        + ustm.entry
        + ustm.fence
        + ustm.alt
end
local il = pipe.interlace({"s", "i"})
local generateTerminalsDual = function(config)
    local platformZ = config.hPlatform + 0.53
    return function(edges, terminals, terminalsGroup, arcsL, arcsR, enablers)
        local function xI(seq, seq2)
            local ln2 = seq2 * il * pipe.map(function(s) return {s = s.s, i = s.i, l = line.byPtPt(s.s, s.i)} end)
            return seq * il
                * pipe.zip(func.seq(1, #seq - 1), {"c", "i"})
                * pipe.fold(1,
                    function(rs, c)
                        local ln = line.byPtPt(c.c.s, c.c.i)
                        local r = ln2 * pipe.map(function(s)
                            local x = s.l - ln
                            return (x - s.i):dot(x - s.s) <= 0 and (x - c.c.i):dot(x - c.c.s) <= 0
                        end)
                        * pipe.filter(pipe.noop())
                        
                        return r and (c.i + 1) or rs
                    end)
        end
        
        local llx, rlx = ust.coordIntersection(arcsL.lane.rc, arcsR.lane.lc)
        
        local lc, rc = arcsL.lane.lc * pipe.range(1, llx), arcsR.lane.rc * pipe.range(1, rlx)
        local llc, lrc = arcsL.lane.lc * pipe.range(llx, #arcsL.lane.lc), arcsL.lane.rc * pipe.range(llx, #arcsL.lane.rc)
        local rlc, rrc = arcsR.lane.lc * pipe.range(rlx, #arcsR.lane.lc), arcsR.lane.rc * pipe.range(rlx, #arcsR.lane.rc)
        
        local terminalsL = arcsL.lane.lc * il * pipe.map(function(lc)
            return station.newModel(enablers[1] and "ust/terminal_lane.mdl" or "ust/standard_lane.mdl", ust.mRot(lc.s - lc.i), coor.trans(lc.i))
        end)
        
        local terminalsR = arcsR.lane.rc * il * pipe.map(function(lc)
            return station.newModel(enablers[2] and "ust/terminal_lane.mdl" or "ust/standard_lane.mdl", ust.mRot(lc.s - lc.i), coor.trans(lc.i))
        end)
        
        local links = pipe.new
            + pipe.mapn(lc * il + llc * il + rlc * il, rc * il + lrc * il + rrc * il)
            (function(lc, rc) return (lc.s:avg(lc.i) - rc.s:avg(rc.i)):length() > 0.5 and station.newModel("ust/standard_lane.mdl", ust.mRot(lc.s:avg(lc.i) - rc.s:avg(rc.i)), coor.trans(rc.i:avg(rc.s))) end)
            + func.map(il(lrc), function(c) return station.newModel("ust/standard_lane.mdl", ust.mRot(c.s - c.i), coor.trans(c.i)) end)
            + func.map(il(rlc), function(c) return station.newModel("ust/standard_lane.mdl", ust.mRot(c.s - c.i), coor.trans(c.i)) end)
        
        local newTerminals = pipe.new
            / terminalsL
            / terminalsR
            / links
        
        return terminals + newTerminals * pipe.flatten(),
            terminalsGroup
            + (
            (enablers[1] and enablers[2]) and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[1]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 16
                },
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[2]) * pipe.map(function(s) return {s - 1 + #terminals + #newTerminals[1], 0} end),
                    vehicleNodeOverride = #edges * 8 - 7
                }
            } or enablers[1] and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[1]) * pipe.map(function(s) return {s - 1 + #terminals, 0} end),
                    vehicleNodeOverride = #edges * 8 - 8
                }
            } or enablers[2] and {
                {
                    terminals = pipe.new * func.seq(1, #newTerminals[2]) * pipe.map(function(s) return {s - 1 + #terminals + #newTerminals[1], 0} end),
                    vehicleNodeOverride = #edges * 8 - 7
                }
            } or {}
    )
    end
end

local generateModelsDual = function(config, fitModel)
    local tZ = coor.transZ(config.hPlatform - 1.4)
    local platformZ = config.hPlatform + 0.53
    
    return function(arcsL, arcsR, edgeBuilder)
        local edgeBuilder = edgeBuilder or function(platformEdgeO, _) return platformEdgeO, platformEdgeO end
        
        local intersection = arcsL.intersection
        local commonLength = arcsL.commonLength
        
        local function modelSeq(arcs, intersection, commonLength, isLeft)
            local lc, rc, lic, ric, c = arcs.platform.lc, arcs.platform.rc, arcs.surface.lc, arcs.surface.rc, arcs.surface.c
            local lpc, rpc, lpic, rpic, pc = arcs.roof.edge.lc, arcs.roof.edge.rc, arcs.roof.surface.lc, arcs.roof.surface.rc, arcs.roof.edge.c
            local lpp, rpp, ppc = arcs.roof.pole.lc, arcs.roof.pole.rc, arcs.roof.pole.c
            local lcc, rcc, cc = arcs.chair.lc, arcs.chair.rc, arcs.chair.c
            
            local platformSurface = pipe.new
                * pipe.rep(c - 2)(config.models.surface)
                * pipe.mapi(function(p, i) return (i == (c > 5 and 4 or 2) or (i == floor(c * 0.5) + 4) and (arcs.hasLower or arcs.hasUpper)) and config.models.stair or config.models.surface end)
                / config.models.extremity
                * (function(ls) return ls * pipe.rev() + ls end)
            
            local platformSurfaceEx = pipe.new
                * pipe.rep(c - 2)(config.models.surface)
                / config.models.extremity
                * (function(ls) return ls * pipe.rev() + ls end)
            
            local platformEdgeO = pipe.new
                * pipe.rep(c - 2)(config.models.edge)
                / config.models.corner
                * (function(ls) return ls * pipe.rev() + ls end)
            
            local platformEdgeL, platformEdgeR = edgeBuilder(platformEdgeO, c)
            
            local fn = pipe.mapi(function(m, i) return
                i >= intersection and i < commonLength and config.models.edgeSurface
                or i ~= commonLength and m
                or commonLength == 2 * (c - 1) and config.models.edgeSurfaceExtreme
                or config.models.edgeSurfaceCorner
            end)
            
            if isLeft then
                platformEdgeR = platformEdgeR * fn
            else
                platformEdgeL = platformEdgeL * fn
            end
            
            local platformEdgeSurface = pipe.new
                * pipe.rep(c - 1)(config.models.edgeSurface)
                * (function(ls) return ls * pipe.rev() + ls end)
            
            local roofSurface = pipe.new
                * pipe.rep(pc - 2)(config.models.roofTop)
                / config.models.roofExtremity
                * (function(ls) return ls * pipe.rev() + ls end)
            
            local roofEdge = pipe.new
                * pipe.rep(pc - 2)(config.models.roofEdge)
                / config.models.roofCorner
                * (function(ls) return ls * pipe.rev() + ls end)
            
            return {
                platformSurface = platformSurface,
                platformSurfaceEx = platformSurfaceEx,
                platformEdgeSurface = platformEdgeSurface,
                platformEdgeO = platformEdgeO,
                platformEdgeL = platformEdgeL,
                platformEdgeR = platformEdgeR,
                roofSurface = roofSurface,
                roofEdge = roofEdge
            }
        end
        
        local platformSurface = function(c)
            return function(i, s, sx, lic, ric)
                local lic = i >= c and lic or {s = lic.i, i = lic.s}
                local ric = i >= c and ric or {s = ric.i, i = ric.s}
                
                local sizeS = ust.assembleSize(lic, ric)
                
                local surfaces = pipe.exec * function()
                    local vecs = {
                        top = sizeS.rt - sizeS.lt,
                        bottom = sizeS.rb - sizeS.lb
                    }
                    if (vecs.top:length() < 7 and vecs.bottom:length() < 7) then
                        return pipe.new
                            / station.newModel(s .. "_br.mdl", tZ, fitModel(3.4, 5, platformZ, sizeS, false, false))
                            / station.newModel(s .. "_tl.mdl", tZ, fitModel(3.4, 5, platformZ, sizeS, true, true))
                    else
                        local n = (function(l)
                            return
                            (l - floor(l) < 0.5)
                                and (function(n) return n % 2 == 0 and n - 1 or n end)(floor(l))
                                or (function(n) return n % 2 == 0 and n + 1 or n end)(ceil(l))
                        end)((vecs.top:length() + vecs.bottom:length()) / 14)
                        
                        local h = (n - 1) * 0.5
                        
                        local sizeS2 = {
                            lb = sizeS.lb + vecs.bottom * h / n,
                            lt = sizeS.lt + vecs.top * h / n,
                            rb = sizeS.rb - vecs.bottom * h / n,
                            rt = sizeS.rt - vecs.top * h / n,
                        }
                        
                        return pipe.new
                            * func.seq(1, h)
                            * pipe.map(function(i)
                                local size = {
                                    lb = sizeS.lb + vecs.bottom * (i - 1) / n,
                                    lt = sizeS.lt + vecs.top * (i - 1) / n,
                                    rb = sizeS.lb + vecs.bottom * i / n,
                                    rt = sizeS.lt + vecs.top * i / n,
                                }
                                
                                return pipe.new
                                    / station.newModel(sx .. "_br.mdl", tZ, fitModel(3.4, 5, platformZ, size, false, false))
                                    / station.newModel(sx .. "_tl.mdl", tZ, fitModel(3.4, 5, platformZ, size, true, true))
                            end)
                            * pipe.flatten()
                            + {
                                station.newModel(s .. "_br.mdl", tZ, fitModel(3.4, 5, platformZ, sizeS2, false, false)),
                                station.newModel(s .. "_tl.mdl", tZ, fitModel(3.4, 5, platformZ, sizeS2, true, true))
                            }
                            +
                            pipe.new
                            * func.seq(1, h)
                            * pipe.map(function(i)
                                local size = {
                                    lb = sizeS.rb - vecs.bottom * i / n,
                                    lt = sizeS.rt - vecs.top * i / n,
                                    rb = sizeS.rb - vecs.bottom * (i - 1) / n,
                                    rt = sizeS.rt - vecs.top * (i - 1) / n,
                                }
                                
                                return pipe.new
                                    / station.newModel(sx .. "_br.mdl", tZ, fitModel(3.4, 5, platformZ, size, false, false))
                                    / station.newModel(sx .. "_tl.mdl", tZ, fitModel(3.4, 5, platformZ, size, true, true))
                            end)
                            * pipe.flatten()
                    end
                end
                return surfaces
            end
        end
        
        local platformModels = function(c)
            local platformSurface = platformSurface(c)
            return
                function(i, el, er, s, sx, lc, rc, lic, ric)
                    local surface = platformSurface(i, s, sx, lic, ric)
                    local lc = i >= c and lc or {s = lc.i, i = lc.s}
                    local rc = i >= c and rc or {s = rc.i, i = rc.s}
                    local lic = i >= c and lic or {s = lic.i, i = lic.s}
                    local ric = i >= c and ric or {s = ric.i, i = ric.s}
                    
                    local sizeL = ust.assembleSize(lc, lic)
                    local sizeR = ust.assembleSize(ric, rc)
                    
                    return surface
                        / station.newModel(el .. "_br.mdl", tZ, fitModel(0.8, 5, platformZ, sizeL, false, false))
                        / station.newModel(el .. "_tl.mdl", tZ, fitModel(0.8, 5, platformZ, sizeL, true, true))
                        / station.newModel(er .. "_bl.mdl", tZ, fitModel(0.8, 5, platformZ, sizeR, false, true))
                        / station.newModel(er .. "_tr.mdl", tZ, fitModel(0.8, 5, platformZ, sizeR, true, false))
                end
        end
        
        local models = {
            l = modelSeq(arcsL, intersection, commonLength, true),
            r = modelSeq(arcsR, intersection, commonLength, false)
        }
        
        local function commonParts()
            local lc, rc, lic, ric, c = arcsL.platform.lc, arcsR.platform.rc, arcsL.surface.lc, arcsR.surface.rc, arcsL.surface.c
            return pipe.mapn(func.seq(1, intersection - 1),
                models.l.platformEdgeL,
                models.r.platformEdgeR,
                models.l.platformSurface,
                models.l.platformSurfaceEx,
                il(lc), il(rc), il(lic), il(ric))(platformModels(c))
        end
        
        local function middlePart()
            local lc, rc, c = arcsL.platform.rc, arcsR.platform.lc, arcsL.surface.c
            local fn = function(f, t)
                local range = pipe.range(f, t)
                return pipe.mapn(func.seq(f, t),
                    models.l.platformSurfaceEx * pipe.range(f, t - 1) / config.models.extremity,
                    models.l.platformSurfaceEx * pipe.range(f, t - 1) / config.models.extremity,
                    lc * il * range,
                    rc * il * range
            ) end
            return pipe.new + fn(intersection, commonLength)(platformSurface(c))
        end
        
        local function leftPart()
            local lc, rc, lic, ric, c = arcsL.platform.lc, arcsL.platform.rc, arcsL.surface.lc, arcsL.surface.rc, arcsL.surface.c
            local fn = function(f, t)
                local range = pipe.range(f, t)
                return pipe.mapn(func.seq(f, t),
                    models.l.platformEdgeL * range,
                    models.l.platformEdgeR * range,
                    models.l.platformSurface * range,
                    models.l.platformSurfaceEx * range,
                    lc * il * range,
                    rc * il * range,
                    lic * il * range,
                    ric * il * range
            ) end
            return pipe.new + fn(intersection, #models.l.platformEdgeL)(platformModels(c))
        end
        
        
        local function rightPart()
            local lc, rc, lic, ric, c = arcsR.platform.lc, arcsR.platform.rc, arcsR.surface.lc, arcsR.surface.rc, arcsR.surface.c
            local fn = function(f, t)
                local range = pipe.range(f, t)
                return pipe.mapn(func.seq(f, t),
                    models.r.platformEdgeL * range,
                    models.r.platformEdgeR * range,
                    models.r.platformSurface * range,
                    models.r.platformSurfaceEx * range,
                    lc * il * range,
                    rc * il * range,
                    lic * il * range,
                    ric * il * range
            )
            end
            return pipe.new + fn(intersection, #models.r.platformEdgeL)(platformModels(c))
        end
        
        local cp = commonParts()
        local lp = leftPart()
        local rp = rightPart()
        local mp = middlePart()
        
        return (pipe.new / cp / lp / rp / mp) * pipe.flatten() * pipe.flatten()
    end
end

local arcPacker = function(length, slope, rot, con)
    return function(radius, o, lengthVar, dislodge)
        local lengthVar = lengthVar and (1 - lengthVar) or 0
        local dislodge = dislodge and (dislodge * length / radius) or 0
        return function(z)
            local z = z or 0
            return function(lengthOverride)
                local l = lengthOverride and lengthOverride(length) or length
                return function(xDr)
                    local dr = xDr or 0
                    local ar = arc.byOR(o + coor.xyz(0, 0, z), abs(radius - dr))
                    local dRad = (radius > 0 and 1 or -1) * (l - length * lengthVar) / ar.r * 0.5
                    local initRad = (radius > 0 and pi or 0) + rot + con
                    return pipe.new
                        / ar:withLimits({
                            sup = initRad - dislodge - dRad,
                            inf = initRad - dislodge,
                            slope = -slope
                        })
                        / ar:withLimits({
                            inf = initRad - dislodge,
                            sup = initRad - dislodge + dRad,
                            slope = slope
                        })
                end
            end
        end
    end
end

local function retriveRef(config, arcCoords)
    if (not config.buildingParams) then return false end
    
    local central = arcCoords * pipe.filter(function(ar)
        local le, re = ar.platform.lc[#ar.platform.lc], ar.platform.rc[#ar.platform.rc]
        return (le - re):length() > (config.buildingParams.halfWidth) * 2
    end)
    
    if (#central == 0) then return false end
    
    local central = table.unpack(central)
    return function()
        local pl, la, su = central.platform, central.lane, central.surface
        local fplc = floor(pl.c * 0.5)
        local flac = floor(la.c * 0.5)
        local le, re = pl.lc[#pl.lc], pl.rc[#pl.rc]
        local refVec = (le - re):normalized() .. coor.rotZ(-0.5 * pi)
        local refPt = le:avg(re) + refVec
        local stairSurface = (central.hasLower or central.hasUpper) and (la.c + 4 + flac) or (la.c + (la.c > 5 and 4 or 2))
        local stairUnderground = (central.hasLower or central.hasUpper) and (pl.c + 3 + fplc) or (la.c + 3)
        return refPt,
            ust.mRot(refVec),
            la.lc[stairSurface]:avg(la.rc[stairSurface], la.lc[stairSurface + 1], la.rc[stairSurface + 1]),
            pl.lc[stairUnderground]:avg(pl.rc[stairUnderground])
    end
end

local buildStation = function(nbTracksA, nbTracksB, arcPackerA, arcPackerB, config, hasFirst, hasCentral, hasLast)
    local pW = config.wPlatform
    local tW = config.wTrack
    local bandWidth = 0.8
    local pWe = config.wExtPlatform * (pW - bandWidth * 2) + bandWidth * 2
    local fitModel = slope == 0 and ust.fitModel2D or ust.fitModel
    
    local ptListA = ust.preBuild(nbTracksA, config.nbTransitTracksA, config.posTransitTracksA, not hasCentral, not hasFirst)(nbTracksA, pipe.new) * pipe.rev()
    local ptListB = ust.preBuild(nbTracksB, config.nbTransitTracksB, config.posTransitTracksB, not hasCentral, not hasLast)(nbTracksB, pipe.new)
    
    local ptListIA = ptListA * pipe.range(1, #ptListA - (hasCentral and 1 or 0)) * pipe.zip(func.seq(1, #ptListA), {"t", "i"})
    local ptListIB = ptListB * pipe.range(hasCentral and 2 or 1, #ptListB) * pipe.zip(func.seq(#ptListA + 1, #ptListA + #ptListB + 1), {"t", "i"})
    
    local middlePos = hasCentral and #ptListA or (#ptListA + 0.5)
    local leftGroup = ptListIA * pipe.rev()
    local middleGroup = pipe.new * (hasCentral and {{i = #ptListA, t = false}} or {})
    local rightGroup = ptListIB
    
    local platformArcGen = ust.platformArcGen(tW, pW)
    
    local lengthFn = function(posPct) return 1 - (1 - config.lExtPlatform) * ust.varFn(config.lExtPlatform)[config.varModelLength](posPct) end
    local widthFn = function(posPct) return (1 - (1 - config.wExtPlatform) * ust.varFn(config.wExtPlatform)[config.varModelWidth](posPct)) * (pW - bandWidth * 2) + bandWidth * 2 end
    
    local function generateArcs(init, initDr, initX)
        
        local function arcGen(result, r, o, isRight)
            return isRight
                and function(t, ...)
                    if t == nil then
                        return result * pipe.sort(function(l, r) return l.i < r.i end) * pipe.map(pipe.select("a"))
                            * pipe.fold(pipe.new, function(r, a) return #a == 4 and (r / {a[1], a[3]} / {a[4], a[2]}) or (r / a) end)
                    else
                        local posPct = abs(t.i - middlePos) / (#rightGroup)
                        local isVar = posPct >= config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and -posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPackerB(r - tW, o, isVar and lengthPct or 1, offsetPct)}},
                                r - tW, o, true)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(result / {
                                    i = t.i,
                                    a = {
                                        arcPackerB(r - (0.5 * tW), o, lengthPct, offsetPct),
                                        arcPackerB(r - (0.5 * tW + pW), o, lengthPct, offsetPct)
                                    }},
                                r - pW, o, true)(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local r, o, a = platformArcGen(arcPackerB)(r, o, lengthPct, offsetPct, pWe, true)
                                return arcGen(result / {i = t.i, a = a},
                                    r, o, true)(...)
                            end
                        end
                    end
                end
                or function(t, ...)
                    if t == nil then
                        return arcGen(result, initDr[#initDr], initX[#initX], true)(table.unpack(rightGroup))
                    else
                        local posPct = abs(t.i - middlePos) / (#leftGroup)
                        local isVar = posPct >= config.varNbUnaffected
                        local lengthPct = isVar and lengthFn(posPct) or 1
                        local offsetPct = isVar and posPct * config.yOffsetPlatform or 0
                        if t.t then
                            return arcGen(result / {i = t.i, a = {arcPackerA(r + tW, o, lengthPct, offsetPct)}},
                                r + tW, o)(...)
                        else
                            if (not isVar or (config.wExtPlatform == 1)) then
                                return arcGen(result / {
                                    i = t.i,
                                    a = {
                                        arcPackerA(r + (0.5 * tW + pW), o, lengthPct, offsetPct),
                                        arcPackerA(r + (0.5 * tW), o, lengthPct, offsetPct)
                                    }},
                                r + pW, o)(...)
                            else
                                local pWe = isVar and widthFn(posPct) or pW
                                local r, o, a = platformArcGen(arcPackerA)(r, o, lengthPct, offsetPct, pWe, false)
                                return arcGen(result / {i = t.i, a = a},
                                    r, o)(...)
                            end
                        end
                    end
                end
        end
        local rs = arcGen(init, initDr[1], initX[1])(table.unpack(leftGroup))
        return rs
    end
    local allArcs = pipe.exec * function()
        local oA = coor.xyz(config.rA, 0, 0)
        local oB = coor.xyz(config.rB, 0, 0) + coor.xyz(cos(config.convRad) - 1, sin(config.convRad), 0) * config.rB + coor.xyz(1 - cos(config.convRad), sin(config.convRad), 0) * pW
        if (hasCentral) then
            local arcA = arcPackerA(config.rA + 0.5 * pW, oA)
            local arcB = arcPackerB(config.rB - 0.5 * pW, oB)
            local _, _, arcAi = platformArcGen(arcPackerA)(config.rA + 0.5 * pW + 0.5 * tW, oA, 1, 0, pWe, true)
            local _, _, arcBi = platformArcGen(arcPackerB)(config.rB - 0.5 * pW + 0.5 * tW, oB, 1, 0, pWe, false)
            return generateArcs(
                pipe.new / {
                    i = middlePos,
                    a = {
                        arcA,
                        arcB,
                        arcAi[2],
                        arcBi[2]
                    }
                },
                {
                    config.rA - (-0.5 * pW + 0.5 * tW),
                    config.rB - (0.5 * pW - 0.5 * tW)
                }, {oA, oB}
        )
        else
            return generateArcs(
                pipe.new * {},
                {
                    config.rA - (0.5 * tW),
                    config.rB - (-0.5 * tW)
                }, {oA, oB}
        )
        end
    end
    * ust.allArcs(arcGen, config)
    * function(allArcs)
        for i = 1, #allArcs - 1 do
            if #allArcs[i] > 1 and #allArcs[i + 1] > 1 then
                local arcsL, arcsR = allArcs[i], allArcs[i + 1]
                local greater = function(x, y) return x > y and x or y end
                
                local intersection = greater(ust.coordIntersection(arcsL.platform.rc, arcsR.platform.lc))
                
                local lengthRange = function()
                    local max = arcsL.platform.c > arcsR.platform.c and 2 * (arcsR.platform.c - 1) or 2 * (arcsL.platform.c - 1)
                    return pipe.new
                        * (pipe.mapn(func.seq(intersection, max), arcsL.platform.rc * pipe.range(intersection, max + 1) * il, arcsR.platform.lc * pipe.range(intersection, max + 1) * il)
                        (function(i, l, r)
                            local vecL = (l.i - l.s):withZ(0)
                            local vecR = (r.i - l.s):withZ(0)
                            local vec = (r.s - l.s):withZ(0)
                            return vec:cross(vecL).z > 0 and vec:cross(vecR).z < 0 and i or false
                        end))
                        * pipe.filter(pipe.noop())
                        * function(r) return #r > 0 and r[#r] or max end
                end
                
                local commonLength = intersection + floor(config.lengthMiddlePlatform * (lengthRange() - intersection))
                
                local ptL = arcsL.surface.lc[intersection]
                local ptR = arcsR.surface.rc[intersection]
                local vec = ptR - ptL
                
                local lL = (arcsL.surface.lc[intersection + 1] - arcsL.surface.rc[intersection + 1]):length()
                local rL = (arcsR.surface.lc[intersection + 1] - arcsR.surface.rc[intersection + 1]):length()
                local mL = (arcsR.surface.lc[intersection + 1] - arcsL.surface.rc[intersection + 1]):length()

                arcsL.platform.rc[intersection] = ptL + vec * (lL / (lL + rL + mL))
                arcsR.platform.lc[intersection] = ptL + vec * ((mL + lL) / (lL + rL + mL))
                arcsL.surface.rc[intersection] = arcsL.platform.rc[intersection] - vec:normalized() * 0.8
                arcsR.surface.lc[intersection] = arcsR.platform.lc[intersection] + vec:normalized() * 0.8

                arcsL.intersection = intersection
                arcsR.intersection = intersection
                arcsL.commonLength = commonLength
                arcsR.commonLength = commonLength
            end
        end
        return allArcs
    end
    
    local arcCoords = allArcs * pipe.filter(function(a) return #a > 1 end)
    local retriveRef = retriveRef(config, arcCoords)
    
    local entryConfig = ust.entryConfig(config, allArcs, arcCoords, retriveRef)
    
    local build = ust.build(
        config,
        fitModel,
        pipe.new
        / uste.buildEntry(config, entryConfig, retriveRef)
        / uste.buildUndergroundEntry(config, entryConfig)
        / uste.buildSecondEntrySlope(config, entryConfig),
        generateTerminalsDual(config),
        generateModelsDual(config, fitModel)
    )
    return build(pipe.new, pipe.new, pipe.new, pipe.new, pipe.new, ust.trackGrouping(pipe.new, table.unpack(allArcs)))
end

local updateFn = function()
    return ust.safeBuild(params, function(params)
        local trackType = ustm.trackList[params.trackType + 1]
        local trackWidth = ustm.trackWidthList[params.trackType + 1]
        local catenary = params.catenary == 1
        local trackBuilder = trackEdge.builder(catenary, trackType)
        local hPlatform = ustm.hPlatformList[params.hPlatform + 1] * 0.001
        local wPlatform = ustm.wPlatformList[params.wPlatform + 1]
        local roofLength = ustm.roofLengthList[params.roofLength + 1] * 0.01
        local mainBuilding = params.entrySize > 0 and buildingList[params.entrySize]
        local fencesLength = ustm.fencesLengthList[params.fencesStyle + 1]
        local fencesModel = ust.fencesGen(params.fencesColor + 1, params.fencesStyle + 1)
        
        
        local nbTracksA = ustm.trackNumberList[params.nbTracksA + 1]
        local nbTracksB = ustm.trackNumberList[params.nbTracksB + 1]
        local radiusA = (ustm.rList[params.radiusA + 1] * 1000) * (params.curveLayout == 2 and 1 or -1)
        local radiusB = (ustm.rList[params.radiusB + 1] * 1000) * (params.curveLayout == 0 and -1 or 1)
        
        if (params.curveLayout == 0 and radiusA < radiusB) or (params.curveLayout == 2 and radiusA < radiusB) then
            radiusA, radiusB = radiusB, radiusA
        end
        
        local slope = ustm.slopeList[params.slope + 1] * 0.001 * (params.slopeSign == 0 and 1 or -1)
        
        local lengthA = min(ustm.trackLengths[params.lengthA + 1], abs(radiusA * pi * 1.5))
        local lengthB = min(ustm.trackLengths[params.lengthB + 1], abs(radiusB * pi * 1.5))
        
        local entryConfig = {
            main = {
                pos = mainBuilding and (params.entryPos - 1),
                model = mainBuilding,
            },
            street = {
                pipe.mapn(
                    {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1},
                    {params.entryASide < 2, params.entryBSide < 2, params.entryCSide < 2}
                )(function(t, v) return t and v end),
                pipe.mapn(
                    {params.entryAType == 1, params.entryBType == 1, params.entryCType == 1},
                    {params.entryASide > 0, params.entryBSide > 0, params.entryCSide > 0}
                )(function(t, v) return t and v end)
            },
            underground = {
                pipe.mapn(
                    {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0},
                    {params.entryASide < 2, params.entryBSide < 2, params.entryCSide < 2}
                )(function(t, v) return t and v end),
                pipe.mapn(
                    {params.entryAType == 0, params.entryBType == 0, params.entryCType == 0},
                    {params.entryASide > 0, params.entryBSide > 0, params.entryCSide > 0}
                )(function(t, v) return t and v end)
            }
        }
        
        local edge, streetEdge, terminals, terminalsGroup, models, terrain =
            buildStation(nbTracksA, nbTracksB,
                arcPacker(lengthA, slope, lengthA / radiusA * 0.5, 0),
                arcPacker(lengthB, slope, lengthB / radiusB * 0.5, pi * ustm.convAngle[params.convAngle + 1] / 180),
                {
                    nbTransitTracksA = params.nbTransitTracksA,
                    posTransitTracksA = params.posTransitTracksA,
                    nbTransitTracksB = params.nbTransitTracksB,
                    posTransitTracksB = params.posTransitTracksB,
                    convRad = pi * ustm.convAngle[params.convAngle + 1] / 180,
                    rA = radiusA,
                    rB = radiusB,
                    hPlatform = hPlatform,
                    wPlatform = wPlatform,
                    wExtPlatform = ustm.extWidthList[params.wExtPlatform + 1] * 0.01,
                    lExtPlatform = ustm.extLengthList[params.lExtPlatform + 1] * 0.01,
                    yOffsetPlatform = ustm.yOffsetList[params.yOffsetPlatform + 1] * (params.yOffsetPlatformSign == 0 and 0.01 or -0.01),
                    varNbUnaffected = ustm.varUnaffectedList[params.varNbUnaffected + 1] * 0.01,
                    varModelLength = params.varModelLength + 1,
                    varModelWidth = params.varModelWidth + 1,
                    wTrack = trackWidth,
                    roofLength = roofLength,
                    buildingParams = buildingParamsList[params.entrySize],
                    slope = slope,
                    fencesModel = fencesModel,
                    fencesLength = fencesLength,
                    leftFences = params.fencesPos == 1 or params.fencesPos == 3,
                    rightFences = params.fencesPos == 2 or params.fencesPos == 3,
                    entries = entryConfig,
                    models = models,
                    lengthMiddlePlatform = ustm.middlePlatformLength[params.lengthMiddlePlatform + 1] * 0.01
                },
                params.hasLeftPlatform == 1,
                params.hasMiddlePlatform == 1,
                params.hasRightPlatform == 1
        )
        return
            pipe.new
            * {
                edgeLists = pipe.new
                / (pipe.new * {edge * station.mergeEdges} * station.prepareEdges * trackBuilder.normal())
                + streetEdge
                ,
                models = terminals + models,
                terminalGroups = terminalsGroup,
                terrainAlignmentLists = station.mergePoly(table.unpack(terrain))(),
                groundFaces = terrain
                * pipe.map(pipe.select("equal"))
                * pipe.filter(pipe.noop())
                * pipe.flatten()
                * pipe.map(function(f) return {
                    {face = f, modes = {{type = "FILL", key = "industry_gravel_small_01"}}},
                    {face = f, modes = {{type = "STROKE_OUTER", key = "building_paving"}}}
                } end)
                * pipe.flatten()
            }
    end)
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Triangle Station"),
            description = _("Station that platform and track parameters can be fine-tuned, with two different radii on two sides of the station.")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 5013,
        params = params(),
        updateFn = updateFn()
    }
end
