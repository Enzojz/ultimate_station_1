local func = require "ustation/func"
local coor = require "ustation/coor"
local arc = require "ustation/coorarc"
local line = require "ustation/coorline"
local quat = require "ustation/quaternion"
local station = require "ustation/stationlib"
local pipe = require "ustation/pipe"
local ust = require "ustation"
local ustp = require "ustation_planner"

local dump = require "luadump"

local unpack = table.unpack
local ma = math
local atan2 = ma.atan2
local abs = ma.abs
local ceil = ma.ceil
local floor = ma.floor
local pi = ma.pi
local atan = ma.atan
local pow = ma.pow
local cos = ma.cos
local sin = ma.sin
local asin = ma.asin
local min = ma.min

local cov = function(m)
    return func.seqMap({0, 3}, function(r)
        return func.seqMap({1, 4}, function(c)
            return m[r * 4 + c]
        end)
    end)
end

local arcGen = function(p, o, m)
    local _, r, _ = coor.decomposite(m)
    local dRad = atan2(r[5], r[1])
    return {
        l = p.l(-o),
        r = p.r(o) * pipe.map(function(rx) return rx:withLimits({o = rx.o .. m, sup = rx.sup - dRad, inf = rx.inf - dRad}) end)
    } end

local mc = function(lc, rc) return func.map2(lc, rc, function(l, r) return l:avg(r) end) end

local arcPacker = function(length, slope, ratio)
    return function(radiusA, oA, radiusB, oB)
        local initRadA = (radiusA > 0 and pi or 0)
        local initRadB = (radiusB > 0 and pi or 0)
        return function(xDr0)
            local xDr0 = xDr0 or 0
            return function(z)
                local z = z or 0
                return function(lengthOverride)
                    local l = lengthOverride and lengthOverride(length) or length
                    return function(xDr)
                        local dr = xDr0 + (xDr or 0)
                        local arA = arc.byOR(oA + coor.xyz(0, 0, z), abs(radiusA - dr))
                        local arB = arc.byOR(oB + coor.xyz(0, 0, z), abs(radiusB - dr))
                        local radA = (radiusA > 0 and 1 or -1) * (l * ratio) / arA.r
                        local radB = (radiusB > 0 and 1 or -1) * (l * (1 - ratio)) / arB.r
                        return pipe.new
                            / arA:withLimits({
                                sup = initRadA - radA,
                                inf = initRadA,
                                slope = -slope
                            })
                            / arB:withLimits({
                                inf = initRadB,
                                sup = initRadB + radB,
                                slope = slope
                            })
                    end
                end
            end
        end
    end
end


local findMarkers = function(group)
    return pipe.new
        * game.interface.getEntities({pos = game.gui.getTerrainPos(), radius = 1000})
        * pipe.map(game.interface.getEntity)
        * pipe.filter(function(data) return data.fileName and string.match(data.fileName, "utimate_station_planner.con") and data.params and data.params.group == group end)
end

local findTrackDraft = function(group)
    return pipe.new
        * game.interface.getEntities({pos = game.gui.getTerrainPos(), radius = 1000})
        * pipe.map(game.interface.getEntity)
        * pipe.filter(function(data) return data.params and data.params.group == group and data.params.tag == "track" end)
end

local findPlatformDraft = function(group)
    return pipe.new
        * game.interface.getEntities({pos = game.gui.getTerrainPos(), radius = 1000})
        * pipe.map(game.interface.getEntity)
        * pipe.filter(function(data) return data.params and data.params.group == group and data.params.tag == "platform" end)
end

local coordGenTr = function(config)
    local refZ = config.hPlatform + 0.53
    return function(arc)
        local left = arc(0.5 * config.tW)
        local right = arc(-0.5 * config.tW)
        local general = {
            l = left(refZ)(),
            r = right(refZ)()
        }
        
        local arcs = {
            edge = arcGen(general, 0, coor.I())
        }
        local lcc, rcc, cc = ust.biLatCoords(5)(arcs.edge.l, arcs.edge.r)
        
        return {
            [1] = arc,
            left = left,
            right = right,
            edge = func.with(arcs.edge, {lc = lcc, rc = rcc, mc = mc(lcc, rcc), c = cc}),
            isTrack = true
        }
    end
end

local coordGen = function(config)
    local refZ = config.hPlatform + 0.53
    return function(arcL, arcR, m, transf)
        local lane = {
            l = arcL(refZ)(function(l) return l - 3 end),
            r = arcR(refZ)(function(l) return l - 3 end)
        }
        local general = {
            l = arcL(refZ)(),
            r = arcR(refZ)()
        }
        local roof = {
            l = arcL(refZ)(function(l) return l * config.roofLength end),
            r = arcR(refZ)(function(l) return l * config.roofLength end)
        }
        local terrain = {
            l = arcL()(function(l) return l + 5 end),
            r = arcR()(function(l) return l + 5 end)
        }
        
        local arcs = {
            platform = {
                lane = arcGen(lane, config.size.lane, m),
                laneEdge = arcGen(lane, config.size.laneEdge, m),
                edge = arcGen(general, config.size.edge, m),
                surface = arcGen(general, config.size.surface, m),
                access = arcGen(general, config.size.access, m),
            },
            roof = {
                edge = arcGen(roof, config.size.roof.edge, m),
                surface = arcGen(roof, config.size.roof.surface, m)
            },
            terrain = arcGen(terrain, config.size.terrain, m),
            track = arcGen(general, -0.5 * config.tW, m)
        }
        
        local lc, rc, lec, rec, c = ust.biLatCoords(5)(arcs.platform.lane.l, arcs.platform.lane.r, arcs.platform.laneEdge.l, arcs.platform.laneEdge.r)
        local lsc, rsc, lac, rac, lsuc, rsuc, ltc, rtc, ltrc, rtrc, sc =
            ust.biLatCoords(5)(
                arcs.platform.edge.l,
                arcs.platform.edge.r,
                arcs.platform.access.l,
                arcs.platform.access.r,
                arcs.platform.surface.l,
                arcs.platform.surface.r,
                arcs.terrain.l,
                arcs.terrain.r,
                arcs.track.l,
                arcs.track.r
        )
        local lcc, rcc, cc = ust.biLatCoords(10)(arcs.platform.edge.l, arcs.platform.edge.r)
        local lpc, rpc, lpic, rpic, pc = ust.biLatCoords(5)(arcs.roof.edge.l, arcs.roof.edge.r, arcs.roof.surface.l, arcs.roof.surface.r)
        local lppc, rppc, ppc = ust.biLatCoords(10)(arcs.roof.edge.l, arcs.roof.edge.r)
        
        local lpcc, rpcc, mpcc = table.unpack(
            pipe.new
            * pipe.mapn(lsuc, rsuc)(function(lc, rc)
                local vec = (rc - lc)
                local width = vec:length()
                vec = vec:normalized() * 0.5 * (width >= 3 and 2 or width >= 2 and (width - 1) or width >= 0.5 and 0.5 or false)
                local mc = lc:avg(rc)
                return vec and {mc - vec, mc + vec, mc} or {false, false, mc}
            end
            )
            * pipe.fold({pipe.new, pipe.new, pipe.new}, function(r, c) return {r[1] / c[1], r[2] / c[2], r[3] / c[3]} end)
        )
        return {
            [1] = arcL,
            [2] = arcR,
            transf = transf,
            platform = {
                lane = func.with(arcs.platform.lane, {lc = lc, rc = rc, mc = mc(lc, rc), c = c}),
                laneEdge = func.with(arcs.platform.laneEdge, {lc = lec, rc = rec, mc = mc(lec, rec), c = c}),
                surface = func.with(arcs.platform.surface, {lc = lsuc, rc = rsuc, mc = mpcc, c = sc}),
                stair = func.with(arcs.platform.surface, {lc = lpcc, rc = rpcc, mc = mpcc, c = sc}),
                edge = func.with(arcs.platform.edge, {lc = lsc, rc = rsc, mc = mc(lsc, rsc), c = sc}),
                access = func.with(arcs.platform.access, {lc = lac, rc = rac, mc = mc(lac, rac), c = sc}),
                chair = func.with(arcs.platform.edge, {lc = lcc, rc = rcc, mc = mc(lcc, rcc), c = cc}),
            },
            roof = {
                edge = func.with(arcs.roof.edge, {lc = lpc, rc = rpc, mc = mc(lpc, rpc), c = pc}),
                surface = func.with(arcs.roof.surface, {lc = lpic, rc = rpic, mc = mc(lpic, rpic), c = pc}),
                pole = func.with(arcs.roof.edge, {lc = lppc, rc = rppc, mc = mc(lppc, rppc), c = ppc})
            },
            track = func.with(arcs.track, {lc = ltrc, rc = rtrc, mc = mc(ltrc, rtrc), c = pc}),
            terrain = func.with(arcs.terrain, {lc = ltc, rc = rtc, mc = mc(ltc, rtc), c = sc}),
            hasLower = (sc - 5 - floor(sc * 0.5) > 0) and (c - 5 - floor(c * 0.5) > 0),
            hasUpper = (sc + 5 + floor(sc * 0.5) <= #lsc) and (c + 5 + floor(c * 0.5) <= #lc),
            isPlatform = true
        }
    end
end

local prefixM = "ust/1990/"
local models = ust.models(prefixM)

local config = {
    hPlatform = 1.2,
    models = ust.models(prefixM),
    roofLength = 0.8,
    tW = 5,
    size = {
        lane = 1,
        laneEdge = -0.5,
        edge = -0.5,
        surface = 0.3,
        access = -4.25,
        roof = {
            edge = -0.5,
            surface = 0.5
        },
        terrain = -0.5
    },
    width = {
        edge = 0.8,
        surface = 3.4,
        roof = {
            edge = 1,
            surface = 3
        }
    }
}

local buildDraft = function(markers, group)
    if (#markers == 0 or #markers % 2 ~= 0) then return end
    local vecs = markers * pipe.map(function(m) return coor.xyz(1, 0, 0) .. ({coor.decomposite(m.transf)})[2] end)
    local refVec = vecs[1]
    
    local partition =
        vecs
        * pipe.map(function(v) return v:dot(refVec) > 0 end)
        * pipe.zip(markers, {"b", "m"})
        * pipe.fold({pipe.new, pipe.new}, function(r, m) return m.b and {r[1] / m.m, r[2]} or {r[1], r[2] / m.m} end)
    local fm, tm = table.unpack(partition)
    if (#fm == #tm) then
        local sfm = fm
            * pipe.map(function(m)
                local pos, rot = coor.decomposite(m.transf)
                return {m, pos, (coor.xyz(1, 0, 0) .. rot)} end)
            * pipe.sort(function(l, r) return l[3]:cross(r[2] - l[2]).z < 0 end)
            * pipe.map(pipe.select(1))
        local stm = tm
            * pipe.map(function(m)
                local pos, rot = coor.decomposite(m.transf)
                return {m, pos, (coor.xyz(1, 0, 0) .. rot)} end)
            * pipe.sort(function(l, r) return l[3]:cross(r[2] - l[2]).z > 0 end)
            * pipe.map(pipe.select(1))
        
        local tracks = pipe.mapn(sfm, stm, func.seq(1, #sfm))(
            function(f, t, i)
                local f, radius, f2, radius2, length, slope, transf = ustp.solve(f, t)
                
                local r1 = f * radius
                local r2 = f2 and radius2 and f2 * radius2 or f * radius
                return func.with(coordGenTr(config)
                    (arcPacker(length, slope, 0.5)(r1, coor.xyz(r1, 0, 0), r2, coor.xyz(r2, 0, 0))),
                    {
                        number = i,
                        transf = transf
                    })
            end
        )
        local function platformGen(result, tl, tr, ...)
            if (tr == nil) then return unpack(result / tl) end
            local vecL, rotL, _ = coor.decomposite(tl.transf)
            local vecR, rotR, _ = coor.decomposite(tr.transf)
            local iRot = coor.inv(cov(rotL))
            local m = iRot * rotR * coor.trans((vecR - vecL) .. iRot)
            local coords = coordGen(config)(tl.right, tr.left, m, tl.transf)
            
            local hasPlatform =
                pipe.new
                * func.map2(coords.track.lc, coords.track.rc, function(lc, rc) return (lc - rc):length() >= config.tW + 1 end)
                * pipe.filter(pipe.noop())
                * function(ls) return #ls >= 5 end
            
            if (hasPlatform) then
                return platformGen(result / tl / coords, tr, ...)
            else
                return platformGen(result / tl, tr, ...)
            end
        end
        
        local generatePlatform = function(coords, lTrack, rTrack)
            local _ = pipe.new
                * func.seq(1, 2 * (coords.platform.surface.c - 1))
                * pipe.forEach(function(i)
                    local w1 = (coords.platform.edge.lc[i] - coords.platform.edge.rc[i]):length()
                    local w2 = (coords.platform.edge.lc[i + 1] - coords.platform.edge.rc[i + 1]):length()
                    
                    if (w1 >= config.tW + 1 and w2 >= config.tW + 1) then
                        local id = game.interface.buildConstruction(
                            "station/rail/modular/utimate_station_modular_block.con",
                            func.with(station.pureParams(params), {
                                tag = "platform",
                                coords = coords,
                                group = group,
                                pos = i,
                                config = config,
                                leftTrack = lTrack and lTrack.i,
                                rightTrack = rTrack and rTrack.i
                            }),
                            coords.transf
                        )
                        game.interface.setPlayer(id, game.interface.getPlayer())
                    end
                end)
        end
        
        local generateTrack = function(track)
            local id = game.interface.buildConstruction(
                "station/rail/modular/utimate_station_modular_track.con",
                func.with(station.pureParams(params), {
                    tag = "track",
                    coords = track,
                    group = group,
                    config = config,
                    number = track.number
                }),
                track.transf
            )
            game.interface.setPlayer(id, game.interface.getPlayer())
        end
        
        local function build(gr, ...)
            if (gr == nil) then
                return
            elseif (#gr == 3 and gr[1].isTrack and gr[2].isPlatform and gr[3].isTrack) then
                generatePlatform(gr[2], gr[1], gr[3])
                generateTrack(gr[1])
                generateTrack(gr[3])
                build(...)
            elseif (#gr == 2 and gr[1].isTrack and gr[2].isPlatform) then
                generatePlatform(gr[2], gr[1])
                generateTrack(gr[1])
                build(...)
            elseif (#gr == 2 and gr[1].isPlatform and gr[2].isTrack) then
                generatePlatform(gr[1], false, gr[2])
                generateTrack(gr[2])
                build(...)
            elseif (#gr == 1 and gr[1].isPlatform) then
                generatePlatform(gr[1], false, false)
                build(...)
            -- elseif (#gr == 2 and gr[1].isPlatform and gr[2].isPlatform) then
            -- elseif (#gr == 3 and gr[1].isPlatform and gr[2].isPlatform and gr[3].isTrack) then
            -- elseif (#gr == 4 and gr[1].isTrack and gr[2].isPlatform and gr[3].isPlatform and gr[4].isTrack) then
            else
                generateTrack(gr[1])
                build(...)
            end
        end
        
        build(ust.trackGrouping(pipe.new, platformGen(pipe.new, unpack(tracks))))
    end
end

local updateFn = function(params)
    if (params.mode == 0) then
        local markers = findMarkers(params.group)
        buildDraft(markers, params.group)
    end

    return {
        models = {
            {
                id = "ust/indicator.mdl",
                transf = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}
            }
        },
        edgeLists = {
            {
                type = "TRACK",
                params = {
                    type = "standard.lua",
                    catenary = false
                },
                edges = {
                    {{0.0, 0.0, 0.0}, {5.0, 0.0, 0.0}},
                    {{5.0, 0.0, 0.0}, {5.0, 0.0, 0.0}}
                },
                snapNodes = {0}
            }
        },
        cost = 0,
        bulldozeCost = 0,
        maintenanceCost = 0,
        terrainAlignmentLists = {
            {
                type = "EQUAL",
                faces = {}
            }
        }
    }
end

function data()
    return {
        type = "RAIL_STATION",
        description = {
            name = _("Ultimate Station Modular Planner"),
            description = _("")
        },
        availability = {
            yearFrom = 1850,
            yearTo = 0,
        },
        order = 5010,
        skipCollision = true,
        autoRemovable = false,
        params = {
            {
                key = "mode",
                name = _("Mode"),
                values = {"Draft", "Build", "Reset"},
                defaultIndex = 0
            },
            {
                key = "group",
                name = _("Group"),
                values = {"1", "2", "3", "4", "5"},
                defaultIndex = 0
            }
        },
        updateFn = updateFn
    }
end
